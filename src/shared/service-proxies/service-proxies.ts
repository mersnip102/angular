/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmail(body: MailRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordAccDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Account/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    isCheckDateExpried(userName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsCheckDateExpried?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsCheckDateExpried(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsCheckDateExpried(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsCheckDateExpried(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAuditLog(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AuditLogViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLogService/GetAllAuditLog?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAuditLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAuditLog(<any>response_);
                } catch (e) {
                    return <Observable<AuditLogViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditLogViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAuditLog(response: HttpResponseBase): Observable<AuditLogViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditLogViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditLogViewDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class ChucDanhServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getChucDanhAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ChucDanhPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ChucDanhService/GetChucDanhAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChucDanhAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChucDanhAll(<any>response_);
                } catch (e) {
                    return <Observable<ChucDanhPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChucDanhPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetChucDanhAll(response: HttpResponseBase): Observable<ChucDanhPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChucDanhPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChucDanhPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: ChucDanhInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ChucDanhService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ChucDanhInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChucDanhService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChucDanhService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ChucDanh> {
        let url_ = this.baseUrl + "/api/services/app/ChucDanhService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ChucDanh>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChucDanh>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ChucDanh> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChucDanh.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChucDanh>(<any>null);
    }
}

@Injectable()
export class ConfigServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getConfigs(): Observable<Config[]> {
        let url_ = this.baseUrl + "/api/services/app/ConfigService/GetConfigs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigs(<any>response_);
                } catch (e) {
                    return <Observable<Config[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Config[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigs(response: HttpResponseBase): Observable<Config[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Config.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Config[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveConfig(body: ConfigInputDto | undefined): Observable<ConfigInputDto> {
        let url_ = this.baseUrl + "/api/services/app/ConfigService/SaveConfig";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveConfig(<any>response_);
                } catch (e) {
                    return <Observable<ConfigInputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConfigInputDto>><any>_observableThrow(response_);
        }));
    }

    protected processSaveConfig(response: HttpResponseBase): Observable<ConfigInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigInputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigInputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateConfig(body: ConfigInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ConfigService/UpdateConfig";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateConfig(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateConfig(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteConfig(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ConfigService/DeleteConfig?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteConfig(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteConfig(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param key (optional) 
     * @return Success
     */
    getValueByKey(key: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ConfigService/GetValueByKey?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValueByKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValueByKey(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetValueByKey(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CQueryableServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param ma_dvhc_x (optional) 
     * @return Success
     */
    getXaGeom(ma_dvhc_x: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetXaGeom?";
        if (ma_dvhc_x === null)
            throw new Error("The parameter 'ma_dvhc_x' cannot be null.");
        else if (ma_dvhc_x !== undefined)
            url_ += "ma_dvhc_x=" + encodeURIComponent("" + ma_dvhc_x) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetXaGeom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetXaGeom(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetXaGeom(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param ma_dvhc_h (optional) 
     * @return Success
     */
    getHuyenGeom(ma_dvhc_h: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetHuyenGeom?";
        if (ma_dvhc_h === null)
            throw new Error("The parameter 'ma_dvhc_h' cannot be null.");
        else if (ma_dvhc_h !== undefined)
            url_ += "ma_dvhc_h=" + encodeURIComponent("" + ma_dvhc_h) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHuyenGeom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHuyenGeom(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetHuyenGeom(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param ma_dvhc_t (optional) 
     * @return Success
     */
    getTinhGeom(ma_dvhc_t: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetTinhGeom?";
        if (ma_dvhc_t === null)
            throw new Error("The parameter 'ma_dvhc_t' cannot be null.");
        else if (ma_dvhc_t !== undefined)
            url_ += "ma_dvhc_t=" + encodeURIComponent("" + ma_dvhc_t) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTinhGeom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTinhGeom(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetTinhGeom(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id_pakn (optional) 
     * @return Success
     */
    getPAKNGeom(id_pakn: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetPAKNGeom?";
        if (id_pakn === null)
            throw new Error("The parameter 'id_pakn' cannot be null.");
        else if (id_pakn !== undefined)
            url_ += "id_pakn=" + encodeURIComponent("" + id_pakn) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPAKNGeom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPAKNGeom(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPAKNGeom(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id_pakn (optional) 
     * @return Success
     */
    getPAKNByID_PAKN(id_pakn: number | undefined): Observable<PAKNViewMap> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetPAKNByID_PAKN?";
        if (id_pakn === null)
            throw new Error("The parameter 'id_pakn' cannot be null.");
        else if (id_pakn !== undefined)
            url_ += "id_pakn=" + encodeURIComponent("" + id_pakn) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPAKNByID_PAKN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPAKNByID_PAKN(<any>response_);
                } catch (e) {
                    return <Observable<PAKNViewMap>><any>_observableThrow(e);
                }
            } else
                return <Observable<PAKNViewMap>><any>_observableThrow(response_);
        }));
    }

    protected processGetPAKNByID_PAKN(response: HttpResponseBase): Observable<PAKNViewMap> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PAKNViewMap.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PAKNViewMap>(<any>null);
    }

    /**
     * @param user_id (optional) 
     * @return Success
     */
    mapGetAllPAKN(user_id: number | undefined): Observable<PAKNSForMap[]> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/MapGetAllPAKN?";
        if (user_id === null)
            throw new Error("The parameter 'user_id' cannot be null.");
        else if (user_id !== undefined)
            url_ += "user_id=" + encodeURIComponent("" + user_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMapGetAllPAKN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMapGetAllPAKN(<any>response_);
                } catch (e) {
                    return <Observable<PAKNSForMap[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PAKNSForMap[]>><any>_observableThrow(response_);
        }));
    }

    protected processMapGetAllPAKN(response: HttpResponseBase): Observable<PAKNSForMap[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PAKNSForMap.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PAKNSForMap[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTinh2(): Observable<Tinh[]> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetTinh2";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTinh2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTinh2(<any>response_);
                } catch (e) {
                    return <Observable<Tinh[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Tinh[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTinh2(response: HttpResponseBase): Observable<Tinh[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Tinh.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tinh[]>(<any>null);
    }

    /**
     * @param ma_dvhc_t (optional) 
     * @return Success
     */
    getHuyen2(ma_dvhc_t: string | undefined): Observable<Huyen[]> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetHuyen2?";
        if (ma_dvhc_t === null)
            throw new Error("The parameter 'ma_dvhc_t' cannot be null.");
        else if (ma_dvhc_t !== undefined)
            url_ += "ma_dvhc_t=" + encodeURIComponent("" + ma_dvhc_t) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHuyen2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHuyen2(<any>response_);
                } catch (e) {
                    return <Observable<Huyen[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Huyen[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHuyen2(response: HttpResponseBase): Observable<Huyen[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Huyen.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Huyen[]>(<any>null);
    }

    /**
     * @param ma_dvhc_h (optional) 
     * @return Success
     */
    getXa2(ma_dvhc_h: string | undefined): Observable<Xa[]> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetXa2?";
        if (ma_dvhc_h === null)
            throw new Error("The parameter 'ma_dvhc_h' cannot be null.");
        else if (ma_dvhc_h !== undefined)
            url_ += "ma_dvhc_h=" + encodeURIComponent("" + ma_dvhc_h) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetXa2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetXa2(<any>response_);
                } catch (e) {
                    return <Observable<Xa[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Xa[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetXa2(response: HttpResponseBase): Observable<Xa[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Xa.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Xa[]>(<any>null);
    }

    /**
     * @param wkt_point (optional) 
     * @return Success
     */
    whichTinhContainPoint(wkt_point: string | undefined): Observable<DTOMaTinhHuyenXa> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/WhichTinhContainPoint?";
        if (wkt_point === null)
            throw new Error("The parameter 'wkt_point' cannot be null.");
        else if (wkt_point !== undefined)
            url_ += "wkt_point=" + encodeURIComponent("" + wkt_point) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWhichTinhContainPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWhichTinhContainPoint(<any>response_);
                } catch (e) {
                    return <Observable<DTOMaTinhHuyenXa>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTOMaTinhHuyenXa>><any>_observableThrow(response_);
        }));
    }

    protected processWhichTinhContainPoint(response: HttpResponseBase): Observable<DTOMaTinhHuyenXa> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DTOMaTinhHuyenXa.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTOMaTinhHuyenXa>(<any>null);
    }

    /**
     * @param wkt_point (optional) 
     * @return Success
     */
    whichHuyenContainPoint(wkt_point: string | undefined): Observable<DTOMaTinhHuyenXa> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/WhichHuyenContainPoint?";
        if (wkt_point === null)
            throw new Error("The parameter 'wkt_point' cannot be null.");
        else if (wkt_point !== undefined)
            url_ += "wkt_point=" + encodeURIComponent("" + wkt_point) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWhichHuyenContainPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWhichHuyenContainPoint(<any>response_);
                } catch (e) {
                    return <Observable<DTOMaTinhHuyenXa>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTOMaTinhHuyenXa>><any>_observableThrow(response_);
        }));
    }

    protected processWhichHuyenContainPoint(response: HttpResponseBase): Observable<DTOMaTinhHuyenXa> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DTOMaTinhHuyenXa.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTOMaTinhHuyenXa>(<any>null);
    }

    /**
     * @param wkt_point (optional) 
     * @return Success
     */
    whichXaContainPoint(wkt_point: string | undefined): Observable<DTOMaTinhHuyenXa> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/WhichXaContainPoint?";
        if (wkt_point === null)
            throw new Error("The parameter 'wkt_point' cannot be null.");
        else if (wkt_point !== undefined)
            url_ += "wkt_point=" + encodeURIComponent("" + wkt_point) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWhichXaContainPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWhichXaContainPoint(<any>response_);
                } catch (e) {
                    return <Observable<DTOMaTinhHuyenXa>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTOMaTinhHuyenXa>><any>_observableThrow(response_);
        }));
    }

    protected processWhichXaContainPoint(response: HttpResponseBase): Observable<DTOMaTinhHuyenXa> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DTOMaTinhHuyenXa.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTOMaTinhHuyenXa>(<any>null);
    }

    /**
     * @param _Title (optional) 
     * @param _ma_dvhc_t (optional) 
     * @param _ma_dvhc_h (optional) 
     * @param _ma_dvhc_x (optional) 
     * @param _fromdate (optional) 
     * @param _todate (optional) 
     * @param _IdToChucQLDoiTuong (optional) 
     * @param _IdDoiTuong (optional) 
     * @param _State (optional) 
     * @param _IdLoaiSuKien (optional) 
     * @param _nhomNguoiDung (optional) 
     * @param body (optional) 
     * @return Success
     */
    searchPAKN(_Title: string | undefined, _ma_dvhc_t: string | undefined, _ma_dvhc_h: string | undefined, _ma_dvhc_x: string | undefined, _fromdate: string | undefined, _todate: string | undefined, _IdToChucQLDoiTuong: number | undefined, _IdDoiTuong: number | undefined, _State: number | undefined, _IdLoaiSuKien: number | undefined, _nhomNguoiDung: number | undefined, body: DTOXemBCDVHC[] | undefined): Observable<DTOSearchPAKN[]> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/SearchPAKN?";
        if (_Title === null)
            throw new Error("The parameter '_Title' cannot be null.");
        else if (_Title !== undefined)
            url_ += "_Title=" + encodeURIComponent("" + _Title) + "&";
        if (_ma_dvhc_t === null)
            throw new Error("The parameter '_ma_dvhc_t' cannot be null.");
        else if (_ma_dvhc_t !== undefined)
            url_ += "_ma_dvhc_t=" + encodeURIComponent("" + _ma_dvhc_t) + "&";
        if (_ma_dvhc_h === null)
            throw new Error("The parameter '_ma_dvhc_h' cannot be null.");
        else if (_ma_dvhc_h !== undefined)
            url_ += "_ma_dvhc_h=" + encodeURIComponent("" + _ma_dvhc_h) + "&";
        if (_ma_dvhc_x === null)
            throw new Error("The parameter '_ma_dvhc_x' cannot be null.");
        else if (_ma_dvhc_x !== undefined)
            url_ += "_ma_dvhc_x=" + encodeURIComponent("" + _ma_dvhc_x) + "&";
        if (_fromdate === null)
            throw new Error("The parameter '_fromdate' cannot be null.");
        else if (_fromdate !== undefined)
            url_ += "_fromdate=" + encodeURIComponent("" + _fromdate) + "&";
        if (_todate === null)
            throw new Error("The parameter '_todate' cannot be null.");
        else if (_todate !== undefined)
            url_ += "_todate=" + encodeURIComponent("" + _todate) + "&";
        if (_IdToChucQLDoiTuong === null)
            throw new Error("The parameter '_IdToChucQLDoiTuong' cannot be null.");
        else if (_IdToChucQLDoiTuong !== undefined)
            url_ += "_IdToChucQLDoiTuong=" + encodeURIComponent("" + _IdToChucQLDoiTuong) + "&";
        if (_IdDoiTuong === null)
            throw new Error("The parameter '_IdDoiTuong' cannot be null.");
        else if (_IdDoiTuong !== undefined)
            url_ += "_IdDoiTuong=" + encodeURIComponent("" + _IdDoiTuong) + "&";
        if (_State === null)
            throw new Error("The parameter '_State' cannot be null.");
        else if (_State !== undefined)
            url_ += "_State=" + encodeURIComponent("" + _State) + "&";
        if (_IdLoaiSuKien === null)
            throw new Error("The parameter '_IdLoaiSuKien' cannot be null.");
        else if (_IdLoaiSuKien !== undefined)
            url_ += "_IdLoaiSuKien=" + encodeURIComponent("" + _IdLoaiSuKien) + "&";
        if (_nhomNguoiDung === null)
            throw new Error("The parameter '_nhomNguoiDung' cannot be null.");
        else if (_nhomNguoiDung !== undefined)
            url_ += "_nhomNguoiDung=" + encodeURIComponent("" + _nhomNguoiDung) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchPAKN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPAKN(<any>response_);
                } catch (e) {
                    return <Observable<DTOSearchPAKN[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTOSearchPAKN[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchPAKN(response: HttpResponseBase): Observable<DTOSearchPAKN[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DTOSearchPAKN.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTOSearchPAKN[]>(<any>null);
    }

    /**
     * @param idDoiTuong (optional) 
     * @return Success
     */
    getNguoiDuyetByDoiTuong(idDoiTuong: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetNguoiDuyetByDoiTuong?";
        if (idDoiTuong === null)
            throw new Error("The parameter 'idDoiTuong' cannot be null.");
        else if (idDoiTuong !== undefined)
            url_ += "idDoiTuong=" + encodeURIComponent("" + idDoiTuong) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNguoiDuyetByDoiTuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNguoiDuyetByDoiTuong(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetNguoiDuyetByDoiTuong(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param tochucId (optional) 
     * @return Success
     */
    getDoiTuongXem(userId: number | undefined, tochucId: number | undefined): Observable<DTOUserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetDoiTuongXem?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tochucId === null)
            throw new Error("The parameter 'tochucId' cannot be null.");
        else if (tochucId !== undefined)
            url_ += "TochucId=" + encodeURIComponent("" + tochucId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongXem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongXem(<any>response_);
                } catch (e) {
                    return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongXem(response: HttpResponseBase): Observable<DTOUserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DTOUserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTOUserDoiTuong[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param tochucId (optional) 
     * @return Success
     */
    getDoiTuongDuyet(userId: number | undefined, tochucId: number | undefined): Observable<DTOUserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetDoiTuongDuyet?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tochucId === null)
            throw new Error("The parameter 'tochucId' cannot be null.");
        else if (tochucId !== undefined)
            url_ += "TochucId=" + encodeURIComponent("" + tochucId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongDuyet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongDuyet(<any>response_);
                } catch (e) {
                    return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongDuyet(response: HttpResponseBase): Observable<DTOUserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DTOUserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTOUserDoiTuong[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param tochucId (optional) 
     * @return Success
     */
    getDoiTuongBaoCao(userId: number | undefined, tochucId: number | undefined): Observable<DTOUserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetDoiTuongBaoCao?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tochucId === null)
            throw new Error("The parameter 'tochucId' cannot be null.");
        else if (tochucId !== undefined)
            url_ += "TochucId=" + encodeURIComponent("" + tochucId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongBaoCao(response: HttpResponseBase): Observable<DTOUserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DTOUserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTOUserDoiTuong[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getToChucXem(userId: number | undefined): Observable<DTOUserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetToChucXem?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToChucXem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToChucXem(<any>response_);
                } catch (e) {
                    return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetToChucXem(response: HttpResponseBase): Observable<DTOUserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DTOUserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTOUserDoiTuong[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getToChucDuyet(userId: number | undefined): Observable<DTOUserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetToChucDuyet?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToChucDuyet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToChucDuyet(<any>response_);
                } catch (e) {
                    return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetToChucDuyet(response: HttpResponseBase): Observable<DTOUserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DTOUserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTOUserDoiTuong[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getToChucBaoCao(userId: number | undefined): Observable<DTOUserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetToChucBaoCao?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToChucBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToChucBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTOUserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetToChucBaoCao(response: HttpResponseBase): Observable<DTOUserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DTOUserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTOUserDoiTuong[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getAllDuyetBaoCao(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined, userId: number | undefined): Observable<DTODuyetPAKNPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/GetAllDuyetBaoCao?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDuyetBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDuyetBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<DTODuyetPAKNPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTODuyetPAKNPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDuyetBaoCao(response: HttpResponseBase): Observable<DTODuyetPAKNPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DTODuyetPAKNPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTODuyetPAKNPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    tKUser(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/TKUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTKUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTKUser(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processTKUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    tKToChuc(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/TKToChuc";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTKToChuc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTKToChuc(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processTKToChuc(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param _Title (optional) 
     * @param _ma_dvhc_t (optional) 
     * @param _ma_dvhc_h (optional) 
     * @param _ma_dvhc_x (optional) 
     * @param _fromdate (optional) 
     * @param _todate (optional) 
     * @param _IdToChucQLDoiTuong (optional) 
     * @param _IdDoiTuong (optional) 
     * @param _State (optional) 
     * @param _IdLoaiSuKien (optional) 
     * @param _nhomNguoiDung (optional) 
     * @param body (optional) 
     * @return Success
     */
    tKPAKN(_Title: string | undefined, _ma_dvhc_t: string | undefined, _ma_dvhc_h: string | undefined, _ma_dvhc_x: string | undefined, _fromdate: string | undefined, _todate: string | undefined, _IdToChucQLDoiTuong: number | undefined, _IdDoiTuong: number | undefined, _State: number | undefined, _IdLoaiSuKien: number | undefined, _nhomNguoiDung: number | undefined, body: DTOXemBCDVHC[] | undefined): Observable<DTOTKPAKN> {
        let url_ = this.baseUrl + "/api/services/app/CQueryableService/TKPAKN?";
        if (_Title === null)
            throw new Error("The parameter '_Title' cannot be null.");
        else if (_Title !== undefined)
            url_ += "_Title=" + encodeURIComponent("" + _Title) + "&";
        if (_ma_dvhc_t === null)
            throw new Error("The parameter '_ma_dvhc_t' cannot be null.");
        else if (_ma_dvhc_t !== undefined)
            url_ += "_ma_dvhc_t=" + encodeURIComponent("" + _ma_dvhc_t) + "&";
        if (_ma_dvhc_h === null)
            throw new Error("The parameter '_ma_dvhc_h' cannot be null.");
        else if (_ma_dvhc_h !== undefined)
            url_ += "_ma_dvhc_h=" + encodeURIComponent("" + _ma_dvhc_h) + "&";
        if (_ma_dvhc_x === null)
            throw new Error("The parameter '_ma_dvhc_x' cannot be null.");
        else if (_ma_dvhc_x !== undefined)
            url_ += "_ma_dvhc_x=" + encodeURIComponent("" + _ma_dvhc_x) + "&";
        if (_fromdate === null)
            throw new Error("The parameter '_fromdate' cannot be null.");
        else if (_fromdate !== undefined)
            url_ += "_fromdate=" + encodeURIComponent("" + _fromdate) + "&";
        if (_todate === null)
            throw new Error("The parameter '_todate' cannot be null.");
        else if (_todate !== undefined)
            url_ += "_todate=" + encodeURIComponent("" + _todate) + "&";
        if (_IdToChucQLDoiTuong === null)
            throw new Error("The parameter '_IdToChucQLDoiTuong' cannot be null.");
        else if (_IdToChucQLDoiTuong !== undefined)
            url_ += "_IdToChucQLDoiTuong=" + encodeURIComponent("" + _IdToChucQLDoiTuong) + "&";
        if (_IdDoiTuong === null)
            throw new Error("The parameter '_IdDoiTuong' cannot be null.");
        else if (_IdDoiTuong !== undefined)
            url_ += "_IdDoiTuong=" + encodeURIComponent("" + _IdDoiTuong) + "&";
        if (_State === null)
            throw new Error("The parameter '_State' cannot be null.");
        else if (_State !== undefined)
            url_ += "_State=" + encodeURIComponent("" + _State) + "&";
        if (_IdLoaiSuKien === null)
            throw new Error("The parameter '_IdLoaiSuKien' cannot be null.");
        else if (_IdLoaiSuKien !== undefined)
            url_ += "_IdLoaiSuKien=" + encodeURIComponent("" + _IdLoaiSuKien) + "&";
        if (_nhomNguoiDung === null)
            throw new Error("The parameter '_nhomNguoiDung' cannot be null.");
        else if (_nhomNguoiDung !== undefined)
            url_ += "_nhomNguoiDung=" + encodeURIComponent("" + _nhomNguoiDung) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTKPAKN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTKPAKN(<any>response_);
                } catch (e) {
                    return <Observable<DTOTKPAKN>><any>_observableThrow(e);
                }
            } else
                return <Observable<DTOTKPAKN>><any>_observableThrow(response_);
        }));
    }

    protected processTKPAKN(response: HttpResponseBase): Observable<DTOTKPAKN> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DTOTKPAKN.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DTOTKPAKN>(<any>null);
    }
}

@Injectable()
export class CSDL1ServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL1Service/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CSDL1> {
        let url_ = this.baseUrl + "/api/services/app/CSDL1Service/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CSDL1>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL1>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CSDL1> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL1.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL1>(<any>null);
    }

    /**
     * @return Success
     */
    getListCSDL1(): Observable<CSDL1[]> {
        let url_ = this.baseUrl + "/api/services/app/CSDL1Service/GetListCSDL1";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListCSDL1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListCSDL1(<any>response_);
                } catch (e) {
                    return <Observable<CSDL1[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL1[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListCSDL1(response: HttpResponseBase): Observable<CSDL1[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CSDL1.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL1[]>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getCSDL1All(skipCount: number | undefined, maxResultCount: number | undefined): Observable<CSDL1PagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CSDL1Service/GetCSDL1All?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL1All(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL1All(<any>response_);
                } catch (e) {
                    return <Observable<CSDL1PagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL1PagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL1All(response: HttpResponseBase): Observable<CSDL1PagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL1PagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL1PagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getCSDL1Reports(): Observable<CSDL1ReportResponse> {
        let url_ = this.baseUrl + "/api/services/app/CSDL1Service/GetCSDL1Reports";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL1Reports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL1Reports(<any>response_);
                } catch (e) {
                    return <Observable<CSDL1ReportResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL1ReportResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL1Reports(response: HttpResponseBase): Observable<CSDL1ReportResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL1ReportResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL1ReportResponse>(<any>null);
    }

    /**
     * @param managerCode (optional) 
     * @return Success
     */
    getCSDL1Chart(managerCode: string | undefined): Observable<CSDL1Chart> {
        let url_ = this.baseUrl + "/api/services/app/CSDL1Service/GetCSDL1Chart?";
        if (managerCode === null)
            throw new Error("The parameter 'managerCode' cannot be null.");
        else if (managerCode !== undefined)
            url_ += "managerCode=" + encodeURIComponent("" + managerCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL1Chart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL1Chart(<any>response_);
                } catch (e) {
                    return <Observable<CSDL1Chart>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL1Chart>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL1Chart(response: HttpResponseBase): Observable<CSDL1Chart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL1Chart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL1Chart>(<any>null);
    }

    /**
     * @return Success
     */
    getCSDL1Dashboard(): Observable<CSDL1Dashboard> {
        let url_ = this.baseUrl + "/api/services/app/CSDL1Service/GetCSDL1Dashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL1Dashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL1Dashboard(<any>response_);
                } catch (e) {
                    return <Observable<CSDL1Dashboard>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL1Dashboard>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL1Dashboard(response: HttpResponseBase): Observable<CSDL1Dashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL1Dashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL1Dashboard>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CSDL1 | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CSDL1Service/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CSDL1 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL1Service/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CSDL2aServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2aService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CSDL2a> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2aService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CSDL2a>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL2a>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CSDL2a> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL2a.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL2a>(<any>null);
    }

    /**
     * @return Success
     */
    getListCSDL2a(): Observable<CSDL2a[]> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2aService/GetListCSDL2a";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListCSDL2a(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListCSDL2a(<any>response_);
                } catch (e) {
                    return <Observable<CSDL2a[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL2a[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListCSDL2a(response: HttpResponseBase): Observable<CSDL2a[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CSDL2a.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL2a[]>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getCSDL2aAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<CSDL2aPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2aService/GetCSDL2aAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL2aAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL2aAll(<any>response_);
                } catch (e) {
                    return <Observable<CSDL2aPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL2aPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL2aAll(response: HttpResponseBase): Observable<CSDL2aPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL2aPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL2aPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CSDL2a | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2aService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CSDL2a | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2aService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param managerCode (optional) 
     * @return Success
     */
    getCSDL2aChart(managerCode: string | undefined): Observable<CSDL2aChart> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2aService/GetCSDL2aChart?";
        if (managerCode === null)
            throw new Error("The parameter 'managerCode' cannot be null.");
        else if (managerCode !== undefined)
            url_ += "managerCode=" + encodeURIComponent("" + managerCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL2aChart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL2aChart(<any>response_);
                } catch (e) {
                    return <Observable<CSDL2aChart>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL2aChart>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL2aChart(response: HttpResponseBase): Observable<CSDL2aChart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL2aChart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL2aChart>(<any>null);
    }

    /**
     * @return Success
     */
    getCSDL2aDashboard(): Observable<CSDL2aDashboard> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2aService/GetCSDL2aDashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL2aDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL2aDashboard(<any>response_);
                } catch (e) {
                    return <Observable<CSDL2aDashboard>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL2aDashboard>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL2aDashboard(response: HttpResponseBase): Observable<CSDL2aDashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL2aDashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL2aDashboard>(<any>null);
    }
}

@Injectable()
export class CSDL2bServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2bService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CSDL2b> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2bService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CSDL2b>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL2b>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CSDL2b> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL2b.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL2b>(<any>null);
    }

    /**
     * @return Success
     */
    getListCSDL2b(): Observable<CSDL2b[]> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2bService/GetListCSDL2b";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListCSDL2b(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListCSDL2b(<any>response_);
                } catch (e) {
                    return <Observable<CSDL2b[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL2b[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListCSDL2b(response: HttpResponseBase): Observable<CSDL2b[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CSDL2b.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL2b[]>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getCSDL2bAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<CSDL2bPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2bService/GetCSDL2bAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL2bAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL2bAll(<any>response_);
                } catch (e) {
                    return <Observable<CSDL2bPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL2bPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL2bAll(response: HttpResponseBase): Observable<CSDL2bPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL2bPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL2bPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CSDL2b | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2bService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CSDL2b | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2bService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param managerCode (optional) 
     * @return Success
     */
    getCSDL2bChart(managerCode: string | undefined): Observable<CSDL2bChart> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2bService/GetCSDL2bChart?";
        if (managerCode === null)
            throw new Error("The parameter 'managerCode' cannot be null.");
        else if (managerCode !== undefined)
            url_ += "managerCode=" + encodeURIComponent("" + managerCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL2bChart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL2bChart(<any>response_);
                } catch (e) {
                    return <Observable<CSDL2bChart>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL2bChart>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL2bChart(response: HttpResponseBase): Observable<CSDL2bChart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL2bChart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL2bChart>(<any>null);
    }

    /**
     * @return Success
     */
    getCSDL2bDashboard(): Observable<CSDL2bDashboard> {
        let url_ = this.baseUrl + "/api/services/app/CSDL2bService/GetCSDL2bDashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL2bDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL2bDashboard(<any>response_);
                } catch (e) {
                    return <Observable<CSDL2bDashboard>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL2bDashboard>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL2bDashboard(response: HttpResponseBase): Observable<CSDL2bDashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL2bDashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL2bDashboard>(<any>null);
    }
}

@Injectable()
export class CSDL3aServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3aService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CSDL3a> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3aService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CSDL3a>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL3a>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CSDL3a> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL3a.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL3a>(<any>null);
    }

    /**
     * @return Success
     */
    getListCSDL3a(): Observable<CSDL3a[]> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3aService/GetListCSDL3a";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListCSDL3a(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListCSDL3a(<any>response_);
                } catch (e) {
                    return <Observable<CSDL3a[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL3a[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListCSDL3a(response: HttpResponseBase): Observable<CSDL3a[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CSDL3a.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL3a[]>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getCSDL3aAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<CSDL3aPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3aService/GetCSDL3aAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL3aAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL3aAll(<any>response_);
                } catch (e) {
                    return <Observable<CSDL3aPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL3aPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL3aAll(response: HttpResponseBase): Observable<CSDL3aPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL3aPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL3aPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CSDL3a | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3aService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CSDL3a | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3aService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param managerCode (optional) 
     * @return Success
     */
    getCSDL3aChart(managerCode: string | undefined): Observable<CSDL3aChart> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3aService/GetCSDL3aChart?";
        if (managerCode === null)
            throw new Error("The parameter 'managerCode' cannot be null.");
        else if (managerCode !== undefined)
            url_ += "managerCode=" + encodeURIComponent("" + managerCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL3aChart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL3aChart(<any>response_);
                } catch (e) {
                    return <Observable<CSDL3aChart>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL3aChart>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL3aChart(response: HttpResponseBase): Observable<CSDL3aChart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL3aChart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL3aChart>(<any>null);
    }

    /**
     * @return Success
     */
    getCSDL3aDashboard(): Observable<CSDL3aDashboard> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3aService/GetCSDL3aDashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL3aDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL3aDashboard(<any>response_);
                } catch (e) {
                    return <Observable<CSDL3aDashboard>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL3aDashboard>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL3aDashboard(response: HttpResponseBase): Observable<CSDL3aDashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL3aDashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL3aDashboard>(<any>null);
    }
}

@Injectable()
export class CSDL3bServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3bService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CSDL3b> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3bService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CSDL3b>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL3b>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CSDL3b> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL3b.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL3b>(<any>null);
    }

    /**
     * @return Success
     */
    getListCSDL3b(): Observable<CSDL3b[]> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3bService/GetListCSDL3b";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListCSDL3b(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListCSDL3b(<any>response_);
                } catch (e) {
                    return <Observable<CSDL3b[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL3b[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListCSDL3b(response: HttpResponseBase): Observable<CSDL3b[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CSDL3b.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL3b[]>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getCSDL3bAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<CSDL3bPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3bService/GetCSDL3bAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL3bAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL3bAll(<any>response_);
                } catch (e) {
                    return <Observable<CSDL3bPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL3bPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL3bAll(response: HttpResponseBase): Observable<CSDL3bPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL3bPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL3bPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CSDL3b | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3bService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CSDL3b | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3bService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param managerCode (optional) 
     * @return Success
     */
    getCSDL3bChart(managerCode: string | undefined): Observable<CSDL3bChart> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3bService/GetCSDL3bChart?";
        if (managerCode === null)
            throw new Error("The parameter 'managerCode' cannot be null.");
        else if (managerCode !== undefined)
            url_ += "managerCode=" + encodeURIComponent("" + managerCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL3bChart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL3bChart(<any>response_);
                } catch (e) {
                    return <Observable<CSDL3bChart>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL3bChart>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL3bChart(response: HttpResponseBase): Observable<CSDL3bChart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL3bChart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL3bChart>(<any>null);
    }

    /**
     * @return Success
     */
    getCSDL3bDashboard(): Observable<CSDL3bDashboard> {
        let url_ = this.baseUrl + "/api/services/app/CSDL3bService/GetCSDL3bDashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL3bDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL3bDashboard(<any>response_);
                } catch (e) {
                    return <Observable<CSDL3bDashboard>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL3bDashboard>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL3bDashboard(response: HttpResponseBase): Observable<CSDL3bDashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL3bDashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL3bDashboard>(<any>null);
    }
}

@Injectable()
export class CSDL4aServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4aService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CSDL4a> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4aService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CSDL4a>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL4a>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CSDL4a> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL4a.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL4a>(<any>null);
    }

    /**
     * @return Success
     */
    getListCSDL4a(): Observable<CSDL4a[]> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4aService/GetListCSDL4a";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListCSDL4a(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListCSDL4a(<any>response_);
                } catch (e) {
                    return <Observable<CSDL4a[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL4a[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListCSDL4a(response: HttpResponseBase): Observable<CSDL4a[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CSDL4a.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL4a[]>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getCSDL4aAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<CSDL4aPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4aService/GetCSDL4aAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL4aAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL4aAll(<any>response_);
                } catch (e) {
                    return <Observable<CSDL4aPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL4aPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL4aAll(response: HttpResponseBase): Observable<CSDL4aPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL4aPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL4aPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CSDL4a | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4aService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CSDL4a | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4aService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param managerCode (optional) 
     * @return Success
     */
    getCSDL4aChart(managerCode: string | undefined): Observable<CSDL4aChart> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4aService/GetCSDL4aChart?";
        if (managerCode === null)
            throw new Error("The parameter 'managerCode' cannot be null.");
        else if (managerCode !== undefined)
            url_ += "managerCode=" + encodeURIComponent("" + managerCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL4aChart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL4aChart(<any>response_);
                } catch (e) {
                    return <Observable<CSDL4aChart>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL4aChart>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL4aChart(response: HttpResponseBase): Observable<CSDL4aChart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL4aChart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL4aChart>(<any>null);
    }

    /**
     * @return Success
     */
    getCSDL4aDashboard(): Observable<CSDL4aDashboard> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4aService/GetCSDL4aDashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL4aDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL4aDashboard(<any>response_);
                } catch (e) {
                    return <Observable<CSDL4aDashboard>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL4aDashboard>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL4aDashboard(response: HttpResponseBase): Observable<CSDL4aDashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL4aDashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL4aDashboard>(<any>null);
    }
}

@Injectable()
export class CSDL4bServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4bService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CSDL4b> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4bService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CSDL4b>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL4b>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CSDL4b> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL4b.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL4b>(<any>null);
    }

    /**
     * @return Success
     */
    getListCSDL4b(): Observable<CSDL4b[]> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4bService/GetListCSDL4b";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListCSDL4b(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListCSDL4b(<any>response_);
                } catch (e) {
                    return <Observable<CSDL4b[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL4b[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListCSDL4b(response: HttpResponseBase): Observable<CSDL4b[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CSDL4b.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL4b[]>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getCSDL4bAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<CSDL4bPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4bService/GetCSDL4bAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL4bAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL4bAll(<any>response_);
                } catch (e) {
                    return <Observable<CSDL4bPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL4bPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL4bAll(response: HttpResponseBase): Observable<CSDL4bPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL4bPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL4bPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CSDL4b | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4bService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CSDL4b | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4bService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param managerCode (optional) 
     * @return Success
     */
    getCSDL4bChart(managerCode: string | undefined): Observable<CSDL4bChart> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4bService/GetCSDL4bChart?";
        if (managerCode === null)
            throw new Error("The parameter 'managerCode' cannot be null.");
        else if (managerCode !== undefined)
            url_ += "managerCode=" + encodeURIComponent("" + managerCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL4bChart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL4bChart(<any>response_);
                } catch (e) {
                    return <Observable<CSDL4bChart>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL4bChart>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL4bChart(response: HttpResponseBase): Observable<CSDL4bChart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL4bChart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL4bChart>(<any>null);
    }

    /**
     * @return Success
     */
    getCSDL4bDashboard(): Observable<CSDL4bDashboard> {
        let url_ = this.baseUrl + "/api/services/app/CSDL4bService/GetCSDL4bDashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCSDL4bDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCSDL4bDashboard(<any>response_);
                } catch (e) {
                    return <Observable<CSDL4bDashboard>><any>_observableThrow(e);
                }
            } else
                return <Observable<CSDL4bDashboard>><any>_observableThrow(response_);
        }));
    }

    protected processGetCSDL4bDashboard(response: HttpResponseBase): Observable<CSDL4bDashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSDL4bDashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CSDL4bDashboard>(<any>null);
    }
}

@Injectable()
export class DiaBanServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DiaBanService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<DiaBan> {
        let url_ = this.baseUrl + "/api/services/app/DiaBanService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<DiaBan>><any>_observableThrow(e);
                }
            } else
                return <Observable<DiaBan>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DiaBan> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiaBan.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiaBan>(<any>null);
    }

    /**
     * @return Success
     */
    getListDiaBan(): Observable<DiaBan[]> {
        let url_ = this.baseUrl + "/api/services/app/DiaBanService/GetListDiaBan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListDiaBan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListDiaBan(<any>response_);
                } catch (e) {
                    return <Observable<DiaBan[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DiaBan[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListDiaBan(response: HttpResponseBase): Observable<DiaBan[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DiaBan.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiaBan[]>(<any>null);
    }

    /**
     * @param maTinh (optional) 
     * @param maHuyen (optional) 
     * @param maXa (optional) 
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDiaBanAll(maTinh: string | undefined, maHuyen: string | undefined, maXa: string | undefined, keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DiaBanPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DiaBanService/GetDiaBanAll?";
        if (maTinh === null)
            throw new Error("The parameter 'maTinh' cannot be null.");
        else if (maTinh !== undefined)
            url_ += "MaTinh=" + encodeURIComponent("" + maTinh) + "&";
        if (maHuyen === null)
            throw new Error("The parameter 'maHuyen' cannot be null.");
        else if (maHuyen !== undefined)
            url_ += "MaHuyen=" + encodeURIComponent("" + maHuyen) + "&";
        if (maXa === null)
            throw new Error("The parameter 'maXa' cannot be null.");
        else if (maXa !== undefined)
            url_ += "MaXa=" + encodeURIComponent("" + maXa) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiaBanAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiaBanAll(<any>response_);
                } catch (e) {
                    return <Observable<DiaBanPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DiaBanPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDiaBanAll(response: HttpResponseBase): Observable<DiaBanPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiaBanPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiaBanPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: DiaBan | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DiaBanService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DiaBan | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DiaBanService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ma_tinh (optional) 
     * @param ma_huyen (optional) 
     * @param ma_xa (optional) 
     * @return Success
     */
    getDiaBanByTHX(ma_tinh: string | undefined, ma_huyen: string | undefined, ma_xa: string | undefined): Observable<DiaBan[]> {
        let url_ = this.baseUrl + "/api/services/app/DiaBanService/GetDiaBanByTHX?";
        if (ma_tinh === null)
            throw new Error("The parameter 'ma_tinh' cannot be null.");
        else if (ma_tinh !== undefined)
            url_ += "ma_tinh=" + encodeURIComponent("" + ma_tinh) + "&";
        if (ma_huyen === null)
            throw new Error("The parameter 'ma_huyen' cannot be null.");
        else if (ma_huyen !== undefined)
            url_ += "ma_huyen=" + encodeURIComponent("" + ma_huyen) + "&";
        if (ma_xa === null)
            throw new Error("The parameter 'ma_xa' cannot be null.");
        else if (ma_xa !== undefined)
            url_ += "ma_xa=" + encodeURIComponent("" + ma_xa) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiaBanByTHX(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiaBanByTHX(<any>response_);
                } catch (e) {
                    return <Observable<DiaBan[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DiaBan[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDiaBanByTHX(response: HttpResponseBase): Observable<DiaBan[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DiaBan.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiaBan[]>(<any>null);
    }
}

@Injectable()
export class DoiTuongServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDoiTuong(body: DoiTuongDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DoiTuong/CreateDoiTuong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDoiTuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDoiTuong(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDoiTuong(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DoiTuong/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDoiTuong(body: DoiTuongDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DoiTuong/UpdateDoiTuong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDoiTuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDoiTuong(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDoiTuong(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<DoiTuongDto> {
        let url_ = this.baseUrl + "/api/services/app/DoiTuong/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<DoiTuongDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DoiTuongDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DoiTuongDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoiTuongDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoiTuongDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDoiTuong(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DoiTuongViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DoiTuong/GetAllDoiTuong?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDoiTuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDoiTuong(<any>response_);
                } catch (e) {
                    return <Observable<DoiTuongViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DoiTuongViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDoiTuong(response: HttpResponseBase): Observable<DoiTuongViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DoiTuongViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoiTuongViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDoiTuongDropdown(): Observable<DoiTuongDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DoiTuong/GetDoiTuongDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongDropdown(<any>response_);
                } catch (e) {
                    return <Observable<DoiTuongDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DoiTuongDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongDropdown(response: HttpResponseBase): Observable<DoiTuongDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DoiTuongDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoiTuongDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenDoiTuongById(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DoiTuong/GetTenDoiTuongById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenDoiTuongById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenDoiTuongById(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenDoiTuongById(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param typePAKN (optional) 
     * @return Success
     */
    getDoiTuongByUserIdDropdown(userId: number | undefined, typePAKN: number | undefined): Observable<DoiTuongDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DoiTuong/GetDoiTuongByUserIdDropdown?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (typePAKN === null)
            throw new Error("The parameter 'typePAKN' cannot be null.");
        else if (typePAKN !== undefined)
            url_ += "typePAKN=" + encodeURIComponent("" + typePAKN) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongByUserIdDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongByUserIdDropdown(<any>response_);
                } catch (e) {
                    return <Observable<DoiTuongDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DoiTuongDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongByUserIdDropdown(response: HttpResponseBase): Observable<DoiTuongDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DoiTuongDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoiTuongDto[]>(<any>null);
    }

    /**
     * @param id_tochuc (optional) 
     * @return Success
     */
    getDoiTuongByToChuc(id_tochuc: number | undefined): Observable<DoiTuongDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DoiTuong/GetDoiTuongByToChuc?";
        if (id_tochuc === null)
            throw new Error("The parameter 'id_tochuc' cannot be null.");
        else if (id_tochuc !== undefined)
            url_ += "id_tochuc=" + encodeURIComponent("" + id_tochuc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongByToChuc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongByToChuc(<any>response_);
                } catch (e) {
                    return <Observable<DoiTuongDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DoiTuongDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongByToChuc(response: HttpResponseBase): Observable<DoiTuongDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DoiTuongDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoiTuongDto[]>(<any>null);
    }
}

@Injectable()
export class DuyetUserDoiTuongServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserDoiTuong(): Observable<DuyetUserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/DuyetUserDoiTuongService/GetUserDoiTuong";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDoiTuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDoiTuong(<any>response_);
                } catch (e) {
                    return <Observable<DuyetUserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DuyetUserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDoiTuong(response: HttpResponseBase): Observable<DuyetUserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DuyetUserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DuyetUserDoiTuong[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertAsyncDuyet(body: DuyetUserDoiTuongDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DuyetUserDoiTuongService/InsertAsyncDuyet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertAsyncDuyet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertAsyncDuyet(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertAsyncDuyet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAsyncDuyet(body: DuyetUserDoiTuongDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DuyetUserDoiTuongService/UpdateAsyncDuyet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAsyncDuyet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAsyncDuyet(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAsyncDuyet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getDoiTuongUserEmpty(userId: number | undefined): Observable<DuyetDoiTuongUserEmpty[]> {
        let url_ = this.baseUrl + "/api/services/app/DuyetUserDoiTuongService/GetDoiTuongUserEmpty?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongUserEmpty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongUserEmpty(<any>response_);
                } catch (e) {
                    return <Observable<DuyetDoiTuongUserEmpty[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DuyetDoiTuongUserEmpty[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongUserEmpty(response: HttpResponseBase): Observable<DuyetDoiTuongUserEmpty[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DuyetDoiTuongUserEmpty.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DuyetDoiTuongUserEmpty[]>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param orgId (optional) 
     * @return Success
     */
    getUserView(keyWord: string | undefined, orgId: number | undefined): Observable<DuyetUserDoiTuongViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DuyetUserDoiTuongService/GetUserView?";
        if (keyWord === null)
            throw new Error("The parameter 'keyWord' cannot be null.");
        else if (keyWord !== undefined)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (orgId === null)
            throw new Error("The parameter 'orgId' cannot be null.");
        else if (orgId !== undefined)
            url_ += "orgId=" + encodeURIComponent("" + orgId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserView(<any>response_);
                } catch (e) {
                    return <Observable<DuyetUserDoiTuongViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DuyetUserDoiTuongViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserView(response: HttpResponseBase): Observable<DuyetUserDoiTuongViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DuyetUserDoiTuongViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DuyetUserDoiTuongViewDto[]>(<any>null);
    }

    /**
     * @param userid (optional) 
     * @return Success
     */
    getDoiTuongByUserId(userid: number | undefined): Observable<DuyetUserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/DuyetUserDoiTuongService/GetDoiTuongByUserId?";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongByUserId(<any>response_);
                } catch (e) {
                    return <Observable<DuyetUserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DuyetUserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongByUserId(response: HttpResponseBase): Observable<DuyetUserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DuyetUserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DuyetUserDoiTuong[]>(<any>null);
    }
}

@Injectable()
export class DVHCServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param ma_dvhc_x (optional) 
     * @return Success
     */
    getDVHCGeom(ma_dvhc_x: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DVHCService/GetDVHCGeom?";
        if (ma_dvhc_x === null)
            throw new Error("The parameter 'ma_dvhc_x' cannot be null.");
        else if (ma_dvhc_x !== undefined)
            url_ += "ma_dvhc_x=" + encodeURIComponent("" + ma_dvhc_x) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDVHCGeom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDVHCGeom(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDVHCGeom(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param ma_dvhc_t (optional) 
     * @return Success
     */
    getHuyen(ma_dvhc_t: string | undefined): Observable<HuyenDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DVHCService/GetHuyen?";
        if (ma_dvhc_t === null)
            throw new Error("The parameter 'ma_dvhc_t' cannot be null.");
        else if (ma_dvhc_t !== undefined)
            url_ += "ma_dvhc_t=" + encodeURIComponent("" + ma_dvhc_t) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHuyen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHuyen(<any>response_);
                } catch (e) {
                    return <Observable<HuyenDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HuyenDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHuyen(response: HttpResponseBase): Observable<HuyenDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HuyenDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HuyenDto[]>(<any>null);
    }

    /**
     * @param ma_dvhc_t (optional) 
     * @param ahuyen (optional) 
     * @return Success
     */
    getHuyenIn(ma_dvhc_t: string | undefined, ahuyen: string[] | undefined): Observable<HuyenDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DVHCService/GetHuyenIn?";
        if (ma_dvhc_t === null)
            throw new Error("The parameter 'ma_dvhc_t' cannot be null.");
        else if (ma_dvhc_t !== undefined)
            url_ += "ma_dvhc_t=" + encodeURIComponent("" + ma_dvhc_t) + "&";
        if (ahuyen === null)
            throw new Error("The parameter 'ahuyen' cannot be null.");
        else if (ahuyen !== undefined)
            ahuyen && ahuyen.forEach(item => { url_ += "ahuyen=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHuyenIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHuyenIn(<any>response_);
                } catch (e) {
                    return <Observable<HuyenDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HuyenDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHuyenIn(response: HttpResponseBase): Observable<HuyenDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HuyenDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HuyenDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTinh(): Observable<TinhDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DVHCService/GetTinh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTinh(<any>response_);
                } catch (e) {
                    return <Observable<TinhDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TinhDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTinh(response: HttpResponseBase): Observable<TinhDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TinhDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinhDto[]>(<any>null);
    }

    /**
     * @param atinh (optional) 
     * @return Success
     */
    getTinhIn(atinh: string[] | undefined): Observable<TinhDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DVHCService/GetTinhIn?";
        if (atinh === null)
            throw new Error("The parameter 'atinh' cannot be null.");
        else if (atinh !== undefined)
            atinh && atinh.forEach(item => { url_ += "atinh=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTinhIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTinhIn(<any>response_);
                } catch (e) {
                    return <Observable<TinhDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TinhDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTinhIn(response: HttpResponseBase): Observable<TinhDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TinhDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinhDto[]>(<any>null);
    }

    /**
     * @param ma_dvhc_h (optional) 
     * @return Success
     */
    getXa(ma_dvhc_h: string | undefined): Observable<XaDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DVHCService/GetXa?";
        if (ma_dvhc_h === null)
            throw new Error("The parameter 'ma_dvhc_h' cannot be null.");
        else if (ma_dvhc_h !== undefined)
            url_ += "ma_dvhc_h=" + encodeURIComponent("" + ma_dvhc_h) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetXa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetXa(<any>response_);
                } catch (e) {
                    return <Observable<XaDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<XaDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetXa(response: HttpResponseBase): Observable<XaDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(XaDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XaDto[]>(<any>null);
    }

    /**
     * @param ma (optional) 
     * @return Success
     */
    getTinhByMa(ma: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DVHCService/GetTinhByMa?";
        if (ma === null)
            throw new Error("The parameter 'ma' cannot be null.");
        else if (ma !== undefined)
            url_ += "ma=" + encodeURIComponent("" + ma) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTinhByMa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTinhByMa(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetTinhByMa(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param ma (optional) 
     * @return Success
     */
    getHuyenByMa(ma: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DVHCService/GetHuyenByMa?";
        if (ma === null)
            throw new Error("The parameter 'ma' cannot be null.");
        else if (ma !== undefined)
            url_ += "ma=" + encodeURIComponent("" + ma) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHuyenByMa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHuyenByMa(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetHuyenByMa(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param ma (optional) 
     * @return Success
     */
    getXaByMa(ma: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DVHCService/GetXaByMa?";
        if (ma === null)
            throw new Error("The parameter 'ma' cannot be null.");
        else if (ma !== undefined)
            url_ += "ma=" + encodeURIComponent("" + ma) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetXaByMa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetXaByMa(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetXaByMa(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getDVHCPhanChoNguoiDung(userId: number | undefined): Observable<UserDVHC[]> {
        let url_ = this.baseUrl + "/api/services/app/DVHCService/GetDVHCPhanChoNguoiDung?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDVHCPhanChoNguoiDung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDVHCPhanChoNguoiDung(<any>response_);
                } catch (e) {
                    return <Observable<UserDVHC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDVHC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDVHCPhanChoNguoiDung(response: HttpResponseBase): Observable<UserDVHC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserDVHC.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDVHC[]>(<any>null);
    }
}

@Injectable()
export class FcmFirebaseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    fcmFireBaseFushNotify(body: ObjNotification | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/FcmFirebase/FcmFireBaseFushNotify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFcmFireBaseFushNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFcmFireBaseFushNotify(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processFcmFireBaseFushNotify(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class HistoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param paknid (optional) 
     * @return Success
     */
    getAll(paknid: number | undefined): Observable<HistoryAddNguoiTaoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/History/GetAll?";
        if (paknid === null)
            throw new Error("The parameter 'paknid' cannot be null.");
        else if (paknid !== undefined)
            url_ += "paknid=" + encodeURIComponent("" + paknid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<HistoryAddNguoiTaoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HistoryAddNguoiTaoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HistoryAddNguoiTaoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HistoryAddNguoiTaoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HistoryAddNguoiTaoDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: HistorysDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/History/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param state (optional) 
     * @return Success
     */
    getState(state: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/History/GetState?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetState(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetState(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class HomeServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getNhacViec(skipCount: number | undefined, maxResultCount: number | undefined, userId: number | undefined): Observable<HomeViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HomeService/GetNhacViec?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNhacViec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNhacViec(<any>response_);
                } catch (e) {
                    return <Observable<HomeViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HomeViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNhacViec(response: HttpResponseBase): Observable<HomeViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HomeViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HomeViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getThongBaoChung_Home(userId: number | undefined): Observable<HomeViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HomeService/GetThongBaoChung_Home?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongBaoChung_Home(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongBaoChung_Home(<any>response_);
                } catch (e) {
                    return <Observable<HomeViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HomeViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetThongBaoChung_Home(response: HttpResponseBase): Observable<HomeViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HomeViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HomeViewDto[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getThongBaoDinhKy_Home(userId: number | undefined): Observable<ThongKeNhacViecDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HomeService/GetThongBaoDinhKy_Home?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongBaoDinhKy_Home(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongBaoDinhKy_Home(<any>response_);
                } catch (e) {
                    return <Observable<ThongKeNhacViecDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThongKeNhacViecDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetThongBaoDinhKy_Home(response: HttpResponseBase): Observable<ThongKeNhacViecDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ThongKeNhacViecDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThongKeNhacViecDto[]>(<any>null);
    }
}

@Injectable()
export class LoaiDoiTuongServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LoaiDoiTuongService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<LoaiDoiTuong> {
        let url_ = this.baseUrl + "/api/services/app/LoaiDoiTuongService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<LoaiDoiTuong>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoaiDoiTuong>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<LoaiDoiTuong> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoaiDoiTuong.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoaiDoiTuong>(<any>null);
    }

    /**
     * @return Success
     */
    getLoaiDoiTuongList(): Observable<LoaiDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/LoaiDoiTuongService/GetLoaiDoiTuongList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoaiDoiTuongList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoaiDoiTuongList(<any>response_);
                } catch (e) {
                    return <Observable<LoaiDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoaiDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoaiDoiTuongList(response: HttpResponseBase): Observable<LoaiDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LoaiDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoaiDoiTuong[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getLoaiDoiTuongAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LoaiDoiTuongPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LoaiDoiTuongService/GetLoaiDoiTuongAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoaiDoiTuongAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoaiDoiTuongAll(<any>response_);
                } catch (e) {
                    return <Observable<LoaiDoiTuongPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoaiDoiTuongPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoaiDoiTuongAll(response: HttpResponseBase): Observable<LoaiDoiTuongPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoaiDoiTuongPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoaiDoiTuongPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: LoaiDoiTuongInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/LoaiDoiTuongService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: LoaiDoiTuongInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LoaiDoiTuongService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MediaServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MediaService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<MediaDto> {
        let url_ = this.baseUrl + "/api/services/app/MediaService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<MediaDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MediaDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<MediaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MediaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MediaDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: MediaDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MediaService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: MediaDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MediaService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paknid (optional) 
     * @return Success
     */
    getMediaPAKNID(paknid: number | undefined): Observable<Media[]> {
        let url_ = this.baseUrl + "/api/services/app/MediaService/GetMediaPAKNID?";
        if (paknid === null)
            throw new Error("The parameter 'paknid' cannot be null.");
        else if (paknid !== undefined)
            url_ += "paknid=" + encodeURIComponent("" + paknid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMediaPAKNID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMediaPAKNID(<any>response_);
                } catch (e) {
                    return <Observable<Media[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Media[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMediaPAKNID(response: HttpResponseBase): Observable<Media[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Media.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Media[]>(<any>null);
    }
}

@Injectable()
export class NhacViecServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NhacViecService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<NhacviecDto> {
        let url_ = this.baseUrl + "/api/services/app/NhacViecService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<NhacviecDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhacviecDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<NhacviecDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhacviecDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhacviecDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getNhacViec(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NhacViecViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NhacViecService/GetNhacViec?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNhacViec(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNhacViec(<any>response_);
                } catch (e) {
                    return <Observable<NhacViecViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhacViecViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNhacViec(response: HttpResponseBase): Observable<NhacViecViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhacViecViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhacViecViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getListUserName(id: number | undefined): Observable<User[]> {
        let url_ = this.baseUrl + "/api/services/app/NhacViecService/GetListUserName?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListUserName(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListUserName(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: NhacviecDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NhacViecService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: NhacviecDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NhacViecService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param roleId (optional) 
     * @return Success
     */
    getUsersByToChucID(input: number[] | undefined, roleId: number | undefined): Observable<User[]> {
        let url_ = this.baseUrl + "/api/services/app/NhacViecService/GetUsersByToChucID?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersByToChucID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersByToChucID(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersByToChucID(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(<any>null);
    }
}

@Injectable()
export class NhiemVuServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NhiemVuService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<NhiemVu> {
        let url_ = this.baseUrl + "/api/services/app/NhiemVuService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<NhiemVu>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhiemVu>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<NhiemVu> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhiemVu.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhiemVu>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getNhiemVuAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NhiemVuPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NhiemVuService/GetNhiemVuAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNhiemVuAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNhiemVuAll(<any>response_);
                } catch (e) {
                    return <Observable<NhiemVuPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhiemVuPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNhiemVuAll(response: HttpResponseBase): Observable<NhiemVuPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhiemVuPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhiemVuPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getNhiemVuList(): Observable<NhiemVu[]> {
        let url_ = this.baseUrl + "/api/services/app/NhiemVuService/GetNhiemVuList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNhiemVuList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNhiemVuList(<any>response_);
                } catch (e) {
                    return <Observable<NhiemVu[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NhiemVu[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNhiemVuList(response: HttpResponseBase): Observable<NhiemVu[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NhiemVu.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhiemVu[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: NhiemVuInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/NhiemVuService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: NhiemVuInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NhiemVuService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NotifyServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    thongBaoDinhKy(userId: number | undefined): Observable<NotifyDto> {
        let url_ = this.baseUrl + "/api/services/app/NotifyService/ThongBaoDinhKy?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThongBaoDinhKy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThongBaoDinhKy(<any>response_);
                } catch (e) {
                    return <Observable<NotifyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotifyDto>><any>_observableThrow(response_);
        }));
    }

    protected processThongBaoDinhKy(response: HttpResponseBase): Observable<NotifyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotifyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotifyDto>(<any>null);
    }

    /**
     * @param usserId (optional) 
     * @return Success
     */
    updateIsReaded(usserId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NotifyService/UpdateIsReaded?";
        if (usserId === null)
            throw new Error("The parameter 'usserId' cannot be null.");
        else if (usserId !== undefined)
            url_ += "usserId=" + encodeURIComponent("" + usserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIsReaded(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIsReaded(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIsReaded(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param userId (optional) 
     * @param id_NguoiBaoCao (optional) 
     * @param id_DoiTuong (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDataByUser(keyword: string | undefined, userId: number | undefined, id_NguoiBaoCao: number | undefined, id_DoiTuong: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ThongKeNhacViecDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NotifyService/GetAllDataByUser?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (id_NguoiBaoCao === null)
            throw new Error("The parameter 'id_NguoiBaoCao' cannot be null.");
        else if (id_NguoiBaoCao !== undefined)
            url_ += "Id_NguoiBaoCao=" + encodeURIComponent("" + id_NguoiBaoCao) + "&";
        if (id_DoiTuong === null)
            throw new Error("The parameter 'id_DoiTuong' cannot be null.");
        else if (id_DoiTuong !== undefined)
            url_ += "Id_DoiTuong=" + encodeURIComponent("" + id_DoiTuong) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDataByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDataByUser(<any>response_);
                } catch (e) {
                    return <Observable<ThongKeNhacViecDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThongKeNhacViecDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDataByUser(response: HttpResponseBase): Observable<ThongKeNhacViecDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThongKeNhacViecDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThongKeNhacViecDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUserBC(): Observable<UserBCDto[]> {
        let url_ = this.baseUrl + "/api/services/app/NotifyService/GetUserBC";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserBC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserBC(<any>response_);
                } catch (e) {
                    return <Observable<UserBCDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserBCDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserBC(response: HttpResponseBase): Observable<UserBCDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserBCDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBCDto[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getDoiTuongByUserBC(userId: number | undefined): Observable<DoiTuongUserBCDto[]> {
        let url_ = this.baseUrl + "/api/services/app/NotifyService/GetDoiTuongByUserBC?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongByUserBC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongByUserBC(<any>response_);
                } catch (e) {
                    return <Observable<DoiTuongUserBCDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DoiTuongUserBCDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongByUserBC(response: HttpResponseBase): Observable<DoiTuongUserBCDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DoiTuongUserBCDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoiTuongUserBCDto[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param idnguoibaocao (optional) 
     * @param iddoituong (optional) 
     * @return Success
     */
    search(userId: number | undefined, idnguoibaocao: number | undefined, iddoituong: number | undefined): Observable<ThongKeNhacViecDto[]> {
        let url_ = this.baseUrl + "/api/services/app/NotifyService/Search?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (idnguoibaocao === null)
            throw new Error("The parameter 'idnguoibaocao' cannot be null.");
        else if (idnguoibaocao !== undefined)
            url_ += "idnguoibaocao=" + encodeURIComponent("" + idnguoibaocao) + "&";
        if (iddoituong === null)
            throw new Error("The parameter 'iddoituong' cannot be null.");
        else if (iddoituong !== undefined)
            url_ += "iddoituong=" + encodeURIComponent("" + iddoituong) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ThongKeNhacViecDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThongKeNhacViecDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ThongKeNhacViecDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ThongKeNhacViecDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThongKeNhacViecDto[]>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<OrganizationUnitDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitService/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<OrganizationUnitDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitService/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitService/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitService/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrg(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitService/DeleteOrg?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrg(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrg(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrg(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param intParent (optional) 
     * @return Success
     */
    getOrganizationUnitsViewDropdown(intParent: number | undefined): Observable<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitService/GetOrganizationUnitsViewDropdown?";
        if (intParent === null)
            throw new Error("The parameter 'intParent' cannot be null.");
        else if (intParent !== undefined)
            url_ += "intParent=" + encodeURIComponent("" + intParent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitsViewDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitsViewDropdown(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitsViewDropdown(response: HttpResponseBase): Observable<OrganizationUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OrganizationUnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto[]>(<any>null);
    }

    /**
     * @param intParent (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getOrganizationUnitsByUserViewDropdown(intParent: number | undefined, userId: number | undefined): Observable<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitService/GetOrganizationUnitsByUserViewDropdown?";
        if (intParent === null)
            throw new Error("The parameter 'intParent' cannot be null.");
        else if (intParent !== undefined)
            url_ += "intParent=" + encodeURIComponent("" + intParent) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitsByUserViewDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitsByUserViewDropdown(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitsByUserViewDropdown(response: HttpResponseBase): Observable<OrganizationUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OrganizationUnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOrganizationUnitsById(id: number | undefined): Observable<CreateOrganizationUnitInput> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitService/GetOrganizationUnitsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitsById(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrganizationUnitInput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrganizationUnitInput>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitsById(response: HttpResponseBase): Observable<CreateOrganizationUnitInput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrganizationUnitInput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrganizationUnitInput>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getToChucByUserId(userId: number | undefined): Observable<OrganizationsUnit> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitService/GetToChucByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToChucByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToChucByUserId(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationsUnit>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationsUnit>><any>_observableThrow(response_);
        }));
    }

    protected processGetToChucByUserId(response: HttpResponseBase): Observable<OrganizationsUnit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationsUnit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationsUnit>(<any>null);
    }

    /**
     * @param doituongid (optional) 
     * @return Success
     */
    getOrganizationUnitsByDoiTuongViewDropdown(doituongid: number | undefined): Observable<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitService/GetOrganizationUnitsByDoiTuongViewDropdown?";
        if (doituongid === null)
            throw new Error("The parameter 'doituongid' cannot be null.");
        else if (doituongid !== undefined)
            url_ += "doituongid=" + encodeURIComponent("" + doituongid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitsByDoiTuongViewDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitsByDoiTuongViewDropdown(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitsByDoiTuongViewDropdown(response: HttpResponseBase): Observable<OrganizationUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OrganizationUnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganizationUnitsViewTree(): Observable<OrganizationViewTreeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitService/GetOrganizationUnitsViewTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitsViewTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitsViewTree(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationViewTreeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationViewTreeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitsViewTree(response: HttpResponseBase): Observable<OrganizationViewTreeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OrganizationViewTreeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationViewTreeDto[]>(<any>null);
    }
}

@Injectable()
export class PAKNServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined, userId: number | undefined): Observable<PAKNDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PAKNDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PAKNDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PAKNDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PAKNDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PAKNDtoPagedResultDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param userId (optional) 
     * @return Success
     */
    getAllDuyetBaoCao(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined, userId: number | undefined): Observable<PAKNDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetAllDuyetBaoCao?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDuyetBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDuyetBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<PAKNDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PAKNDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDuyetBaoCao(response: HttpResponseBase): Observable<PAKNDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PAKNDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PAKNDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: PAKNDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    guiBaoCao(body: PAKNDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GuiBaoCao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGuiBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGuiBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGuiBaoCao(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    duyetBaoCao(body: PAKNDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/DuyetBaoCao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDuyetBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDuyetBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDuyetBaoCao(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PAKNDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<PAKNDto> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PAKNDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PAKNDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PAKNDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PAKNDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PAKNDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLoaiBaoCaoDropdown(): Observable<PAKNTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetLoaiBaoCaoDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoaiBaoCaoDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoaiBaoCaoDropdown(<any>response_);
                } catch (e) {
                    return <Observable<PAKNTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PAKNTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoaiBaoCaoDropdown(response: HttpResponseBase): Observable<PAKNTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PAKNTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PAKNTypeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStateDropdown(): Observable<StateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetStateDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStateDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStateDropdown(<any>response_);
                } catch (e) {
                    return <Observable<StateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStateDropdown(response: HttpResponseBase): Observable<StateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StateDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTrangThaiByID(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetTrangThaiByID?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrangThaiByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrangThaiByID(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrangThaiByID(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getStateDuyetBaoCaoDropdown(): Observable<StateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetStateDuyetBaoCaoDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStateDuyetBaoCaoDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStateDuyetBaoCaoDropdown(<any>response_);
                } catch (e) {
                    return <Observable<StateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStateDuyetBaoCaoDropdown(response: HttpResponseBase): Observable<StateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StateDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStateGuitBaoCaoDropdown(): Observable<StateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetStateGuitBaoCaoDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStateGuitBaoCaoDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStateGuitBaoCaoDropdown(<any>response_);
                } catch (e) {
                    return <Observable<StateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStateGuitBaoCaoDropdown(response: HttpResponseBase): Observable<StateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StateDto[]>(<any>null);
    }

    /**
     * @param paknid (optional) 
     * @return Success
     */
    getToChucByPAKNID(paknid: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetToChucByPAKNID?";
        if (paknid === null)
            throw new Error("The parameter 'paknid' cannot be null.");
        else if (paknid !== undefined)
            url_ += "paknid=" + encodeURIComponent("" + paknid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToChucByPAKNID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToChucByPAKNID(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetToChucByPAKNID(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param paknid (optional) 
     * @return Success
     */
    getToChucIDByPAKNID(paknid: number | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetToChucIDByPAKNID?";
        if (paknid === null)
            throw new Error("The parameter 'paknid' cannot be null.");
        else if (paknid !== undefined)
            url_ += "paknid=" + encodeURIComponent("" + paknid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToChucIDByPAKNID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToChucIDByPAKNID(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetToChucIDByPAKNID(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param paknid (optional) 
     * @return Success
     */
    getToChucNameByPAKNID(paknid: number | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetToChucNameByPAKNID?";
        if (paknid === null)
            throw new Error("The parameter 'paknid' cannot be null.");
        else if (paknid !== undefined)
            url_ += "paknid=" + encodeURIComponent("" + paknid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToChucNameByPAKNID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToChucNameByPAKNID(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetToChucNameByPAKNID(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getRoleGuiBaoCao(userId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetRoleGuiBaoCao?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleGuiBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleGuiBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleGuiBaoCao(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getRoleDuyetBaoCao(userId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetRoleDuyetBaoCao?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleDuyetBaoCao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleDuyetBaoCao(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleDuyetBaoCao(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param iddoituong (optional) 
     * @param loaibaocaoId (optional) 
     * @return Success
     */
    getDayDropdown(userId: number | undefined, iddoituong: number | undefined, loaibaocaoId: NhacViecType | undefined): Observable<Notify[]> {
        let url_ = this.baseUrl + "/api/services/app/PAKN/GetDayDropdown?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (iddoituong === null)
            throw new Error("The parameter 'iddoituong' cannot be null.");
        else if (iddoituong !== undefined)
            url_ += "iddoituong=" + encodeURIComponent("" + iddoituong) + "&";
        if (loaibaocaoId === null)
            throw new Error("The parameter 'loaibaocaoId' cannot be null.");
        else if (loaibaocaoId !== undefined)
            url_ += "loaibaocaoId=" + encodeURIComponent("" + loaibaocaoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDayDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDayDropdown(<any>response_);
                } catch (e) {
                    return <Observable<Notify[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Notify[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDayDropdown(response: HttpResponseBase): Observable<Notify[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Notify.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Notify[]>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(<any>null);
    }

    /**
     * @param lstKey (optional) 
     * @return Success
     */
    getListPermistionDisplayName(lstKey: string[] | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetListPermistionDisplayName?";
        if (lstKey === null)
            throw new Error("The parameter 'lstKey' cannot be null.");
        else if (lstKey !== undefined)
            lstKey && lstKey.forEach(item => { url_ += "lstKey=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListPermistionDisplayName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListPermistionDisplayName(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListPermistionDisplayName(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getAllRoles(permission: string | undefined): Observable<RoleViewDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleViewDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleViewDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<RoleViewDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleViewDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleViewDtoListResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getListRole(): Observable<Role[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetListRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListRole(<any>response_);
                } catch (e) {
                    return <Observable<Role[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListRole(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Role.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role[]>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @return Success
     */
    getUsersByRoleID(roleId: number | undefined): Observable<User[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetUsersByRoleID?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersByRoleID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersByRoleID(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersByRoleID(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getRoleByUserId(userId: number | undefined): Observable<Role[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleByUserId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleByUserId(<any>response_);
                } catch (e) {
                    return <Observable<Role[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleByUserId(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Role.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class SearchPAKNServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param doiTuonng (optional) 
     * @param trangThai (optional) 
     * @param toChuc (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, doiTuonng: number | undefined, trangThai: number | undefined, toChuc: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SearchDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SearchPAKNService/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (doiTuonng === null)
            throw new Error("The parameter 'doiTuonng' cannot be null.");
        else if (doiTuonng !== undefined)
            url_ += "DoiTuonng=" + encodeURIComponent("" + doiTuonng) + "&";
        if (trangThai === null)
            throw new Error("The parameter 'trangThai' cannot be null.");
        else if (trangThai !== undefined)
            url_ += "TrangThai=" + encodeURIComponent("" + trangThai) + "&";
        if (toChuc === null)
            throw new Error("The parameter 'toChuc' cannot be null.");
        else if (toChuc !== undefined)
            url_ += "ToChuc=" + encodeURIComponent("" + toChuc) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SearchDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SearchDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<PAKNDto> {
        let url_ = this.baseUrl + "/api/services/app/SearchPAKNService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PAKNDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PAKNDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PAKNDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PAKNDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PAKNDto>(<any>null);
    }

    /**
     * @return Success
     */
    getStateDropdown(): Observable<StateDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SearchPAKNService/GetStateDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStateDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStateDropdown(<any>response_);
                } catch (e) {
                    return <Observable<StateDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StateDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStateDropdown(response: HttpResponseBase): Observable<StateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(StateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StateDto[]>(<any>null);
    }

    /**
     * @param paknid (optional) 
     * @return Success
     */
    getToChucByPAKNID(paknid: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SearchPAKNService/GetToChucByPAKNID?";
        if (paknid === null)
            throw new Error("The parameter 'paknid' cannot be null.");
        else if (paknid !== undefined)
            url_ += "paknid=" + encodeURIComponent("" + paknid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToChucByPAKNID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToChucByPAKNID(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetToChucByPAKNID(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param paknid (optional) 
     * @return Success
     */
    getToChucIDByPAKNID(paknid: number | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/SearchPAKNService/GetToChucIDByPAKNID?";
        if (paknid === null)
            throw new Error("The parameter 'paknid' cannot be null.");
        else if (paknid !== undefined)
            url_ += "paknid=" + encodeURIComponent("" + paknid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToChucIDByPAKNID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToChucIDByPAKNID(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetToChucIDByPAKNID(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param doiTuonng (optional) 
     * @param trangThai (optional) 
     * @param toChuc (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getSearchPAKN(keyword: string | undefined, doiTuonng: number | undefined, trangThai: number | undefined, toChuc: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SearchDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SearchPAKNService/GetSearchPAKN?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (doiTuonng === null)
            throw new Error("The parameter 'doiTuonng' cannot be null.");
        else if (doiTuonng !== undefined)
            url_ += "DoiTuonng=" + encodeURIComponent("" + doiTuonng) + "&";
        if (trangThai === null)
            throw new Error("The parameter 'trangThai' cannot be null.");
        else if (trangThai !== undefined)
            url_ += "TrangThai=" + encodeURIComponent("" + trangThai) + "&";
        if (toChuc === null)
            throw new Error("The parameter 'toChuc' cannot be null.");
        else if (toChuc !== undefined)
            url_ += "ToChuc=" + encodeURIComponent("" + toChuc) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSearchPAKN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSearchPAKN(<any>response_);
                } catch (e) {
                    return <Observable<SearchDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSearchPAKN(response: HttpResponseBase): Observable<SearchDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SearchDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchDto[]>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class SuKienServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getSuKienAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SuKienPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SuKienService/GetSuKienAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuKienAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuKienAll(<any>response_);
                } catch (e) {
                    return <Observable<SuKienPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SuKienPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSuKienAll(response: HttpResponseBase): Observable<SuKienPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SuKienPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SuKienPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: SuKienInputDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SuKienService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: SuKienInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SuKienService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SuKienService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<SuKien> {
        let url_ = this.baseUrl + "/api/services/app/SuKienService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<SuKien>><any>_observableThrow(e);
                }
            } else
                return <Observable<SuKien>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SuKien> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SuKien.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SuKien>(<any>null);
    }

    /**
     * @return Success
     */
    getSuKienDropdown(): Observable<SuKien[]> {
        let url_ = this.baseUrl + "/api/services/app/SuKienService/GetSuKienDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuKienDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuKienDropdown(<any>response_);
                } catch (e) {
                    return <Observable<SuKien[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SuKien[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSuKienDropdown(response: HttpResponseBase): Observable<SuKien[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SuKien.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SuKien[]>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class ThongBaoNhacViecServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ThongBaoNhacViecDto> {
        let url_ = this.baseUrl + "/api/services/app/ThongBaoNhacViecService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ThongBaoNhacViecDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThongBaoNhacViecDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ThongBaoNhacViecDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThongBaoNhacViecDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThongBaoNhacViecDto>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    updateReadedNotify(userId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ThongBaoNhacViecService/UpdateReadedNotify?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReadedNotify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReadedNotify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateReadedNotify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUsers(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserById(id: number | undefined): Observable<GetUserByIdOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(<any>response_);
                } catch (e) {
                    return <Observable<GetUserByIdOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserByIdOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<GetUserByIdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserByIdOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserByIdOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getAdminUsernames(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAdminUsernames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminUsernames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminUsernames(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdminUsernames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEmail(body: UpdateEmailDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUser(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllUser?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUser(<any>response_);
                } catch (e) {
                    return <Observable<UserViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUser(response: HttpResponseBase): Observable<UserViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserDropDown(): Observable<UserViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllUserDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserDropDown(<any>response_);
                } catch (e) {
                    return <Observable<UserViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserDropDown(response: HttpResponseBase): Observable<UserViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserViewDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInfoUser(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetInfoUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfoUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfoUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInfoUser(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserInfor(body: UpdateInfoUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserInfor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserInfor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserInfor(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserInfor(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getChucDanh(): Observable<ChucDanhInputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetChucDanh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChucDanh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChucDanh(<any>response_);
                } catch (e) {
                    return <Observable<ChucDanhInputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChucDanhInputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetChucDanh(response: HttpResponseBase): Observable<ChucDanhInputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ChucDanhInputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChucDanhInputDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUser_ById(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUser_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser_ById(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser_ById(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getRolesByUserID(userId: number | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRolesByUserID?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolesByUserID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolesByUserID(<any>response_);
                } catch (e) {
                    return <Observable<number[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<number[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolesByUserID(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(<any>null);
    }

    /**
     * @param id_tochuc (optional) 
     * @return Success
     */
    getUserByToChuc(id_tochuc: number | undefined): Observable<User[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserByToChuc?";
        if (id_tochuc === null)
            throw new Error("The parameter 'id_tochuc' cannot be null.");
        else if (id_tochuc !== undefined)
            url_ += "id_tochuc=" + encodeURIComponent("" + id_tochuc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserByToChuc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByToChuc(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserByToChuc(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param idUser_login (optional) 
     * @return Success
     */
    deleteUser(id: number | undefined, idUser_login: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (idUser_login === null)
            throw new Error("The parameter 'idUser_login' cannot be null.");
        else if (idUser_login !== undefined)
            url_ += "idUser_login=" + encodeURIComponent("" + idUser_login) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserDeviceServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userID (optional) 
     * @return Success
     */
    getListDevice(userID: number | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDeviceService/GetListDevice?";
        if (userID === null)
            throw new Error("The parameter 'userID' cannot be null.");
        else if (userID !== undefined)
            url_ += "userID=" + encodeURIComponent("" + userID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListDevice(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListDevice(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class UserDoiTuongServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDoiTuongService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<UserDoiTuongDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDoiTuongService/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<UserDoiTuongDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDoiTuongDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<UserDoiTuongDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDoiTuongDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDoiTuongDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUserDoiTuong(): Observable<UserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDoiTuongService/GetUserDoiTuong";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDoiTuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDoiTuong(<any>response_);
                } catch (e) {
                    return <Observable<UserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDoiTuong(response: HttpResponseBase): Observable<UserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDoiTuong[]>(<any>null);
    }

    /**
     * @param userid (optional) 
     * @return Success
     */
    getDoiTuongByUserId(userid: number | undefined): Observable<UserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDoiTuongService/GetDoiTuongByUserId?";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongByUserId(<any>response_);
                } catch (e) {
                    return <Observable<UserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongByUserId(response: HttpResponseBase): Observable<UserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDoiTuong[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: UserDoiTuongDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDoiTuongService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDoiTuongDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDoiTuongService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getDoiTuongUserEmpty(userId: number | undefined): Observable<DoiTuongUserEmpty[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDoiTuongService/GetDoiTuongUserEmpty?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongUserEmpty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongUserEmpty(<any>response_);
                } catch (e) {
                    return <Observable<DoiTuongUserEmpty[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DoiTuongUserEmpty[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongUserEmpty(response: HttpResponseBase): Observable<DoiTuongUserEmpty[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DoiTuongUserEmpty.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DoiTuongUserEmpty[]>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param orgId (optional) 
     * @return Success
     */
    getUserView(keyWord: string | undefined, orgId: number | undefined): Observable<UserDoiTuongViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDoiTuongService/GetUserView?";
        if (keyWord === null)
            throw new Error("The parameter 'keyWord' cannot be null.");
        else if (keyWord !== undefined)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (orgId === null)
            throw new Error("The parameter 'orgId' cannot be null.");
        else if (orgId !== undefined)
            url_ += "orgId=" + encodeURIComponent("" + orgId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserView(<any>response_);
                } catch (e) {
                    return <Observable<UserDoiTuongViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDoiTuongViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserView(response: HttpResponseBase): Observable<UserDoiTuongViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserDoiTuongViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDoiTuongViewDto[]>(<any>null);
    }
}

@Injectable()
export class UserDVHCServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param ma_dvhc_t (optional) 
     * @return Success
     */
    getAllHuyen(ma_dvhc_t: string | undefined): Observable<ViewHuyenDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDVHCService/GetAllHuyen?";
        if (ma_dvhc_t === null)
            throw new Error("The parameter 'ma_dvhc_t' cannot be null.");
        else if (ma_dvhc_t !== undefined)
            url_ += "ma_dvhc_t=" + encodeURIComponent("" + ma_dvhc_t) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHuyen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHuyen(<any>response_);
                } catch (e) {
                    return <Observable<ViewHuyenDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewHuyenDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHuyen(response: HttpResponseBase): Observable<ViewHuyenDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ViewHuyenDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewHuyenDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTinh(): Observable<ViewTinhDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDVHCService/GetAllTinh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTinh(<any>response_);
                } catch (e) {
                    return <Observable<ViewTinhDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewTinhDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTinh(response: HttpResponseBase): Observable<ViewTinhDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ViewTinhDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewTinhDto[]>(<any>null);
    }

    /**
     * @param ma_dvhc_h (optional) 
     * @return Success
     */
    getAllXa(ma_dvhc_h: string | undefined): Observable<ViewXaDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDVHCService/GetAllXa?";
        if (ma_dvhc_h === null)
            throw new Error("The parameter 'ma_dvhc_h' cannot be null.");
        else if (ma_dvhc_h !== undefined)
            url_ += "ma_dvhc_h=" + encodeURIComponent("" + ma_dvhc_h) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllXa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllXa(<any>response_);
                } catch (e) {
                    return <Observable<ViewXaDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ViewXaDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllXa(response: HttpResponseBase): Observable<ViewXaDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ViewXaDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ViewXaDto[]>(<any>null);
    }

    /**
     * @param keywords (optional) 
     * @return Success
     */
    get_UserDVHCView(keywords: string | undefined): Observable<DVHC_UserViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDVHCService/Get_UserDVHCView?";
        if (keywords === null)
            throw new Error("The parameter 'keywords' cannot be null.");
        else if (keywords !== undefined)
            url_ += "keywords=" + encodeURIComponent("" + keywords) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_UserDVHCView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_UserDVHCView(<any>response_);
                } catch (e) {
                    return <Observable<DVHC_UserViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DVHC_UserViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet_UserDVHCView(response: HttpResponseBase): Observable<DVHC_UserViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DVHC_UserViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DVHC_UserViewDto[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    get_UserView(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDVHCViewDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDVHCService/Get_UserView?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_UserView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_UserView(<any>response_);
                } catch (e) {
                    return <Observable<UserDVHCViewDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDVHCViewDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet_UserView(response: HttpResponseBase): Observable<UserDVHCViewDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDVHCViewDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDVHCViewDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert_UserDVHC(body: CreateUserDVHCDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDVHCService/Insert_UserDVHC";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert_UserDVHC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert_UserDVHC(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsert_UserDVHC(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete_UserDVHC(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDVHCService/Delete_UserDVHC?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete_UserDVHC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete_UserDVHC(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete_UserDVHC(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class XemUserDoiTuongServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserDoiTuong(): Observable<XemUserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/XemUserDoiTuongService/GetUserDoiTuong";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDoiTuong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDoiTuong(<any>response_);
                } catch (e) {
                    return <Observable<XemUserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<XemUserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDoiTuong(response: HttpResponseBase): Observable<XemUserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(XemUserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XemUserDoiTuong[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertAsyncXem(body: XemUserDoiTuongDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/XemUserDoiTuongService/InsertAsyncXem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertAsyncXem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertAsyncXem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertAsyncXem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAsyncXem(body: XemUserDoiTuongDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/XemUserDoiTuongService/UpdateAsyncXem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAsyncXem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAsyncXem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAsyncXem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getDoiTuongUserEmpty(userId: number | undefined): Observable<XemDoiTuongUserEmpty[]> {
        let url_ = this.baseUrl + "/api/services/app/XemUserDoiTuongService/GetDoiTuongUserEmpty?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongUserEmpty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongUserEmpty(<any>response_);
                } catch (e) {
                    return <Observable<XemDoiTuongUserEmpty[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<XemDoiTuongUserEmpty[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongUserEmpty(response: HttpResponseBase): Observable<XemDoiTuongUserEmpty[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(XemDoiTuongUserEmpty.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XemDoiTuongUserEmpty[]>(<any>null);
    }

    /**
     * @param keyWord (optional) 
     * @param orgId (optional) 
     * @return Success
     */
    getUserView(keyWord: string | undefined, orgId: number | undefined): Observable<XemUserDoiTuongViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/XemUserDoiTuongService/GetUserView?";
        if (keyWord === null)
            throw new Error("The parameter 'keyWord' cannot be null.");
        else if (keyWord !== undefined)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        if (orgId === null)
            throw new Error("The parameter 'orgId' cannot be null.");
        else if (orgId !== undefined)
            url_ += "orgId=" + encodeURIComponent("" + orgId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserView(<any>response_);
                } catch (e) {
                    return <Observable<XemUserDoiTuongViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<XemUserDoiTuongViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserView(response: HttpResponseBase): Observable<XemUserDoiTuongViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(XemUserDoiTuongViewDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XemUserDoiTuongViewDto[]>(<any>null);
    }

    /**
     * @param userid (optional) 
     * @return Success
     */
    getDoiTuongByUserId(userid: number | undefined): Observable<XemUserDoiTuong[]> {
        let url_ = this.baseUrl + "/api/services/app/XemUserDoiTuongService/GetDoiTuongByUserId?";
        if (userid === null)
            throw new Error("The parameter 'userid' cannot be null.");
        else if (userid !== undefined)
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoiTuongByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoiTuongByUserId(<any>response_);
                } catch (e) {
                    return <Observable<XemUserDoiTuong[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<XemUserDoiTuong[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoiTuongByUserId(response: HttpResponseBase): Observable<XemUserDoiTuong[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(XemUserDoiTuong.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XemUserDoiTuong[]>(<any>null);
    }
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class AuditLog implements IAuditLog {
    id: number;
    tenantId: number | undefined;
    userId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    returnValue: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exceptionMessage: string | undefined;
    exception: string | undefined;
    impersonatorUserId: number | undefined;
    impersonatorTenantId: number | undefined;
    customData: string | undefined;

    constructor(data?: IAuditLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.returnValue = _data["returnValue"];
            this.executionTime = _data["executionTime"] ? moment(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exceptionMessage = _data["exceptionMessage"];
            this.exception = _data["exception"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.customData = _data["customData"];
        }
    }

    static fromJS(data: any): AuditLog {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["returnValue"] = this.returnValue;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exceptionMessage"] = this.exceptionMessage;
        data["exception"] = this.exception;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["customData"] = this.customData;
        return data; 
    }

    clone(): AuditLog {
        const json = this.toJSON();
        let result = new AuditLog();
        result.init(json);
        return result;
    }
}

export interface IAuditLog {
    id: number;
    tenantId: number | undefined;
    userId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    returnValue: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exceptionMessage: string | undefined;
    exception: string | undefined;
    impersonatorUserId: number | undefined;
    impersonatorTenantId: number | undefined;
    customData: string | undefined;
}

export class AuditLogViewDto implements IAuditLogViewDto {
    auditLog: AuditLog;
    userName: string | undefined;

    constructor(data?: IAuditLogViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auditLog = _data["auditLog"] ? AuditLog.fromJS(_data["auditLog"]) : <any>undefined;
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): AuditLogViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditLog"] = this.auditLog ? this.auditLog.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): AuditLogViewDto {
        const json = this.toJSON();
        let result = new AuditLogViewDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogViewDto {
    auditLog: AuditLog;
    userName: string | undefined;
}

export class AuditLogViewDtoPagedResultDto implements IAuditLogViewDtoPagedResultDto {
    items: AuditLogViewDto[] | undefined;
    totalCount: number;

    constructor(data?: IAuditLogViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AuditLogViewDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AuditLogViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AuditLogViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AuditLogViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogViewDtoPagedResultDto {
    items: AuditLogViewDto[] | undefined;
    totalCount: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    deviceID: string | undefined;
    devicePin: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
            this.deviceID = _data["deviceID"];
            this.devicePin = _data["devicePin"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["deviceID"] = this.deviceID;
        data["devicePin"] = this.devicePin;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    deviceID: string | undefined;
    devicePin: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class CSDL1 implements ICSDL1 {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    projectCode: string | undefined;
    componentCode: string | undefined;
    managerCode: string | undefined;
    createdTime: moment.Moment | undefined;
    centralCode: string | undefined;
    provinceCode: string | undefined;
    districtCode: string | undefined;
    communeCode: string | undefined;

    constructor(data?: ICSDL1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.organizationCode = _data["organizationCode"];
            this.programCode = _data["programCode"];
            this.projectCode = _data["projectCode"];
            this.componentCode = _data["componentCode"];
            this.managerCode = _data["managerCode"];
            this.createdTime = _data["createdTime"] ? moment(_data["createdTime"].toString()) : <any>undefined;
            this.centralCode = _data["centralCode"];
            this.provinceCode = _data["provinceCode"];
            this.districtCode = _data["districtCode"];
            this.communeCode = _data["communeCode"];
        }
    }

    static fromJS(data: any): CSDL1 {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["organizationCode"] = this.organizationCode;
        data["programCode"] = this.programCode;
        data["projectCode"] = this.projectCode;
        data["componentCode"] = this.componentCode;
        data["managerCode"] = this.managerCode;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["centralCode"] = this.centralCode;
        data["provinceCode"] = this.provinceCode;
        data["districtCode"] = this.districtCode;
        data["communeCode"] = this.communeCode;
        return data; 
    }

    clone(): CSDL1 {
        const json = this.toJSON();
        let result = new CSDL1();
        result.init(json);
        return result;
    }
}

export interface ICSDL1 {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    projectCode: string | undefined;
    componentCode: string | undefined;
    managerCode: string | undefined;
    createdTime: moment.Moment | undefined;
    centralCode: string | undefined;
    provinceCode: string | undefined;
    districtCode: string | undefined;
    communeCode: string | undefined;
}

export class CSDL1Chart implements ICSDL1Chart {
    organization: string | undefined;
    assigned: number | undefined;
    allotted: number | undefined;
    percentage: number | undefined;

    constructor(data?: ICSDL1Chart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organization = _data["organization"];
            this.assigned = _data["assigned"];
            this.allotted = _data["allotted"];
            this.percentage = _data["percentage"];
        }
    }

    static fromJS(data: any): CSDL1Chart {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL1Chart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization;
        data["assigned"] = this.assigned;
        data["allotted"] = this.allotted;
        data["percentage"] = this.percentage;
        return data; 
    }

    clone(): CSDL1Chart {
        const json = this.toJSON();
        let result = new CSDL1Chart();
        result.init(json);
        return result;
    }
}

export interface ICSDL1Chart {
    organization: string | undefined;
    assigned: number | undefined;
    allotted: number | undefined;
    percentage: number | undefined;
}

export class CSDL1Dashboard implements ICSDL1Dashboard {
    nationwideAssigned: number | undefined;
    nationwideAllotted: number | undefined;
    centralAssigned: number | undefined;
    centralAllotted: number | undefined;
    provinceAssigned: number | undefined;
    provinceAllotted: number | undefined;
    districtAssigned: number | undefined;
    districtAllotted: number | undefined;
    communeAssigned: number | undefined;
    communeAllotted: number | undefined;
    readonly nationwidePercentage: number | undefined;
    readonly centralPercentage: number | undefined;
    readonly provincePercentage: number | undefined;
    readonly districtPercentage: number | undefined;
    readonly communePercentage: number | undefined;

    constructor(data?: ICSDL1Dashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nationwideAssigned = _data["nationwideAssigned"];
            this.nationwideAllotted = _data["nationwideAllotted"];
            this.centralAssigned = _data["centralAssigned"];
            this.centralAllotted = _data["centralAllotted"];
            this.provinceAssigned = _data["provinceAssigned"];
            this.provinceAllotted = _data["provinceAllotted"];
            this.districtAssigned = _data["districtAssigned"];
            this.districtAllotted = _data["districtAllotted"];
            this.communeAssigned = _data["communeAssigned"];
            this.communeAllotted = _data["communeAllotted"];
            (<any>this).nationwidePercentage = _data["nationwidePercentage"];
            (<any>this).centralPercentage = _data["centralPercentage"];
            (<any>this).provincePercentage = _data["provincePercentage"];
            (<any>this).districtPercentage = _data["districtPercentage"];
            (<any>this).communePercentage = _data["communePercentage"];
        }
    }

    static fromJS(data: any): CSDL1Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL1Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nationwideAssigned"] = this.nationwideAssigned;
        data["nationwideAllotted"] = this.nationwideAllotted;
        data["centralAssigned"] = this.centralAssigned;
        data["centralAllotted"] = this.centralAllotted;
        data["provinceAssigned"] = this.provinceAssigned;
        data["provinceAllotted"] = this.provinceAllotted;
        data["districtAssigned"] = this.districtAssigned;
        data["districtAllotted"] = this.districtAllotted;
        data["communeAssigned"] = this.communeAssigned;
        data["communeAllotted"] = this.communeAllotted;
        data["nationwidePercentage"] = this.nationwidePercentage;
        data["centralPercentage"] = this.centralPercentage;
        data["provincePercentage"] = this.provincePercentage;
        data["districtPercentage"] = this.districtPercentage;
        data["communePercentage"] = this.communePercentage;
        return data; 
    }

    clone(): CSDL1Dashboard {
        const json = this.toJSON();
        let result = new CSDL1Dashboard();
        result.init(json);
        return result;
    }
}

export interface ICSDL1Dashboard {
    nationwideAssigned: number | undefined;
    nationwideAllotted: number | undefined;
    centralAssigned: number | undefined;
    centralAllotted: number | undefined;
    provinceAssigned: number | undefined;
    provinceAllotted: number | undefined;
    districtAssigned: number | undefined;
    districtAllotted: number | undefined;
    communeAssigned: number | undefined;
    communeAllotted: number | undefined;
    nationwidePercentage: number | undefined;
    centralPercentage: number | undefined;
    provincePercentage: number | undefined;
    districtPercentage: number | undefined;
    communePercentage: number | undefined;
}

export class CSDL1PagedResultDto implements ICSDL1PagedResultDto {
    items: CSDL1[] | undefined;
    totalCount: number;

    constructor(data?: ICSDL1PagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CSDL1.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CSDL1PagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL1PagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CSDL1PagedResultDto {
        const json = this.toJSON();
        let result = new CSDL1PagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICSDL1PagedResultDto {
    items: CSDL1[] | undefined;
    totalCount: number;
}

export class CSDL1ReportItem implements ICSDL1ReportItem {
    organization: string | undefined;
    assignedPeriod: number | undefined;
    assignedAccumulatedYtd: number | undefined;
    assignedAccumulatedStd: number | undefined;
    allottedPeriod: number | undefined;
    allottedAccumulatedYtd: number | undefined;
    allottedAccumulatedStd: number | undefined;
    unallotted: number | undefined;
    percentage: number | undefined;

    constructor(data?: ICSDL1ReportItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organization = _data["organization"];
            this.assignedPeriod = _data["assignedPeriod"];
            this.assignedAccumulatedYtd = _data["assignedAccumulatedYtd"];
            this.assignedAccumulatedStd = _data["assignedAccumulatedStd"];
            this.allottedPeriod = _data["allottedPeriod"];
            this.allottedAccumulatedYtd = _data["allottedAccumulatedYtd"];
            this.allottedAccumulatedStd = _data["allottedAccumulatedStd"];
            this.unallotted = _data["unallotted"];
            this.percentage = _data["percentage"];
        }
    }

    static fromJS(data: any): CSDL1ReportItem {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL1ReportItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization;
        data["assignedPeriod"] = this.assignedPeriod;
        data["assignedAccumulatedYtd"] = this.assignedAccumulatedYtd;
        data["assignedAccumulatedStd"] = this.assignedAccumulatedStd;
        data["allottedPeriod"] = this.allottedPeriod;
        data["allottedAccumulatedYtd"] = this.allottedAccumulatedYtd;
        data["allottedAccumulatedStd"] = this.allottedAccumulatedStd;
        data["unallotted"] = this.unallotted;
        data["percentage"] = this.percentage;
        return data; 
    }

    clone(): CSDL1ReportItem {
        const json = this.toJSON();
        let result = new CSDL1ReportItem();
        result.init(json);
        return result;
    }
}

export interface ICSDL1ReportItem {
    organization: string | undefined;
    assignedPeriod: number | undefined;
    assignedAccumulatedYtd: number | undefined;
    assignedAccumulatedStd: number | undefined;
    allottedPeriod: number | undefined;
    allottedAccumulatedYtd: number | undefined;
    allottedAccumulatedStd: number | undefined;
    unallotted: number | undefined;
    percentage: number | undefined;
}

export class CSDL1ReportResponse implements ICSDL1ReportResponse {
    organizationLevel: string | undefined;
    items: CSDL1ReportItem[] | undefined;
    stats: CSDL1ReportItem;

    constructor(data?: ICSDL1ReportResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationLevel = _data["organizationLevel"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CSDL1ReportItem.fromJS(item));
            }
            this.stats = _data["stats"] ? CSDL1ReportItem.fromJS(_data["stats"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CSDL1ReportResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL1ReportResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationLevel"] = this.organizationLevel;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["stats"] = this.stats ? this.stats.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CSDL1ReportResponse {
        const json = this.toJSON();
        let result = new CSDL1ReportResponse();
        result.init(json);
        return result;
    }
}

export interface ICSDL1ReportResponse {
    organizationLevel: string | undefined;
    items: CSDL1ReportItem[] | undefined;
    stats: CSDL1ReportItem;
}

export class CSDL2a implements ICSDL2a {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    projectCode: string | undefined;
    managerCode: string | undefined;
    createdTime: moment.Moment | undefined;

    constructor(data?: ICSDL2a) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.organizationCode = _data["organizationCode"];
            this.programCode = _data["programCode"];
            this.subprojectCode = _data["subprojectCode"];
            this.componentCode = _data["componentCode"];
            this.projectCode = _data["projectCode"];
            this.managerCode = _data["managerCode"];
            this.createdTime = _data["createdTime"] ? moment(_data["createdTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CSDL2a {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL2a();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["organizationCode"] = this.organizationCode;
        data["programCode"] = this.programCode;
        data["subprojectCode"] = this.subprojectCode;
        data["componentCode"] = this.componentCode;
        data["projectCode"] = this.projectCode;
        data["managerCode"] = this.managerCode;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CSDL2a {
        const json = this.toJSON();
        let result = new CSDL2a();
        result.init(json);
        return result;
    }
}

export interface ICSDL2a {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    projectCode: string | undefined;
    managerCode: string | undefined;
    createdTime: moment.Moment | undefined;
}

export class CSDL2aChart implements ICSDL2aChart {
    organization: string | undefined;
    browser: number | undefined;
    decided: number | undefined;
    expense: number | undefined;

    constructor(data?: ICSDL2aChart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organization = _data["organization"];
            this.browser = _data["browser"];
            this.decided = _data["decided"];
            this.expense = _data["expense"];
        }
    }

    static fromJS(data: any): CSDL2aChart {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL2aChart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization;
        data["browser"] = this.browser;
        data["decided"] = this.decided;
        data["expense"] = this.expense;
        return data; 
    }

    clone(): CSDL2aChart {
        const json = this.toJSON();
        let result = new CSDL2aChart();
        result.init(json);
        return result;
    }
}

export interface ICSDL2aChart {
    organization: string | undefined;
    browser: number | undefined;
    decided: number | undefined;
    expense: number | undefined;
}

export class CSDL2aDashboard implements ICSDL2aDashboard {
    nationwideBrowser: number | undefined;
    nationwideDecided: number | undefined;
    nationwideExpense: number | undefined;
    centralBrowser: number | undefined;
    centralDecided: number | undefined;
    centralExpense: number | undefined;
    provinceBrowser: number | undefined;
    provinceDecided: number | undefined;
    provinceExpense: number | undefined;
    districtBrowser: number | undefined;
    districtDecided: number | undefined;
    districtExpense: number | undefined;
    communeBrowser: number | undefined;
    communeDecided: number | undefined;
    communeExpense: number | undefined;

    constructor(data?: ICSDL2aDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nationwideBrowser = _data["nationwideBrowser"];
            this.nationwideDecided = _data["nationwideDecided"];
            this.nationwideExpense = _data["nationwideExpense"];
            this.centralBrowser = _data["centralBrowser"];
            this.centralDecided = _data["centralDecided"];
            this.centralExpense = _data["centralExpense"];
            this.provinceBrowser = _data["provinceBrowser"];
            this.provinceDecided = _data["provinceDecided"];
            this.provinceExpense = _data["provinceExpense"];
            this.districtBrowser = _data["districtBrowser"];
            this.districtDecided = _data["districtDecided"];
            this.districtExpense = _data["districtExpense"];
            this.communeBrowser = _data["communeBrowser"];
            this.communeDecided = _data["communeDecided"];
            this.communeExpense = _data["communeExpense"];
        }
    }

    static fromJS(data: any): CSDL2aDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL2aDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nationwideBrowser"] = this.nationwideBrowser;
        data["nationwideDecided"] = this.nationwideDecided;
        data["nationwideExpense"] = this.nationwideExpense;
        data["centralBrowser"] = this.centralBrowser;
        data["centralDecided"] = this.centralDecided;
        data["centralExpense"] = this.centralExpense;
        data["provinceBrowser"] = this.provinceBrowser;
        data["provinceDecided"] = this.provinceDecided;
        data["provinceExpense"] = this.provinceExpense;
        data["districtBrowser"] = this.districtBrowser;
        data["districtDecided"] = this.districtDecided;
        data["districtExpense"] = this.districtExpense;
        data["communeBrowser"] = this.communeBrowser;
        data["communeDecided"] = this.communeDecided;
        data["communeExpense"] = this.communeExpense;
        return data; 
    }

    clone(): CSDL2aDashboard {
        const json = this.toJSON();
        let result = new CSDL2aDashboard();
        result.init(json);
        return result;
    }
}

export interface ICSDL2aDashboard {
    nationwideBrowser: number | undefined;
    nationwideDecided: number | undefined;
    nationwideExpense: number | undefined;
    centralBrowser: number | undefined;
    centralDecided: number | undefined;
    centralExpense: number | undefined;
    provinceBrowser: number | undefined;
    provinceDecided: number | undefined;
    provinceExpense: number | undefined;
    districtBrowser: number | undefined;
    districtDecided: number | undefined;
    districtExpense: number | undefined;
    communeBrowser: number | undefined;
    communeDecided: number | undefined;
    communeExpense: number | undefined;
}

export class CSDL2aPagedResultDto implements ICSDL2aPagedResultDto {
    items: CSDL2a[] | undefined;
    totalCount: number;

    constructor(data?: ICSDL2aPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CSDL2a.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CSDL2aPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL2aPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CSDL2aPagedResultDto {
        const json = this.toJSON();
        let result = new CSDL2aPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICSDL2aPagedResultDto {
    items: CSDL2a[] | undefined;
    totalCount: number;
}

export class CSDL2b implements ICSDL2b {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    projectCode: string | undefined;
    implementationProgress: string | undefined;
    managerCode: string | undefined;
    createdTime: moment.Moment | undefined;

    constructor(data?: ICSDL2b) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.organizationCode = _data["organizationCode"];
            this.programCode = _data["programCode"];
            this.subprojectCode = _data["subprojectCode"];
            this.componentCode = _data["componentCode"];
            this.projectCode = _data["projectCode"];
            this.implementationProgress = _data["implementationProgress"];
            this.managerCode = _data["managerCode"];
            this.createdTime = _data["createdTime"] ? moment(_data["createdTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CSDL2b {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL2b();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["organizationCode"] = this.organizationCode;
        data["programCode"] = this.programCode;
        data["subprojectCode"] = this.subprojectCode;
        data["componentCode"] = this.componentCode;
        data["projectCode"] = this.projectCode;
        data["implementationProgress"] = this.implementationProgress;
        data["managerCode"] = this.managerCode;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CSDL2b {
        const json = this.toJSON();
        let result = new CSDL2b();
        result.init(json);
        return result;
    }
}

export interface ICSDL2b {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    projectCode: string | undefined;
    implementationProgress: string | undefined;
    managerCode: string | undefined;
    createdTime: moment.Moment | undefined;
}

export class CSDL2bChart implements ICSDL2bChart {
    organization: string | undefined;
    assignedCapital: number | undefined;
    assignedProject: number | undefined;
    disbursedCapital: number | undefined;
    disbursedProject: number | undefined;

    constructor(data?: ICSDL2bChart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organization = _data["organization"];
            this.assignedCapital = _data["assignedCapital"];
            this.assignedProject = _data["assignedProject"];
            this.disbursedCapital = _data["disbursedCapital"];
            this.disbursedProject = _data["disbursedProject"];
        }
    }

    static fromJS(data: any): CSDL2bChart {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL2bChart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization;
        data["assignedCapital"] = this.assignedCapital;
        data["assignedProject"] = this.assignedProject;
        data["disbursedCapital"] = this.disbursedCapital;
        data["disbursedProject"] = this.disbursedProject;
        return data; 
    }

    clone(): CSDL2bChart {
        const json = this.toJSON();
        let result = new CSDL2bChart();
        result.init(json);
        return result;
    }
}

export interface ICSDL2bChart {
    organization: string | undefined;
    assignedCapital: number | undefined;
    assignedProject: number | undefined;
    disbursedCapital: number | undefined;
    disbursedProject: number | undefined;
}

export class CSDL2bDashboard implements ICSDL2bDashboard {
    nationwideAssignedCapital: number | undefined;
    nationwideAssignedProject: number | undefined;
    nationwideDisbursedCapital: number | undefined;
    nationwideDisbursedProject: number | undefined;
    centralAssignedCapital: number | undefined;
    centralAssignedProject: number | undefined;
    centralDisbursedProject: number | undefined;
    centralDisbursedCapital: number | undefined;
    districtAssignedCapital: number | undefined;
    districtAssignedProject: number | undefined;
    districtDisbursedProject: number | undefined;
    districtDisbursedCapital: number | undefined;
    provinceAssignedCapital: number | undefined;
    provinceAssignedProject: number | undefined;
    provinceDisbursedProject: number | undefined;
    provinceDisbursedCapital: number | undefined;
    communeAssignedCapital: number | undefined;
    communeAssignedProject: number | undefined;
    communeDisbursedProject: number | undefined;
    communeDisbursedCapital: number | undefined;

    constructor(data?: ICSDL2bDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nationwideAssignedCapital = _data["nationwideAssignedCapital"];
            this.nationwideAssignedProject = _data["nationwideAssignedProject"];
            this.nationwideDisbursedCapital = _data["nationwideDisbursedCapital"];
            this.nationwideDisbursedProject = _data["nationwideDisbursedProject"];
            this.centralAssignedCapital = _data["centralAssignedCapital"];
            this.centralAssignedProject = _data["centralAssignedProject"];
            this.centralDisbursedProject = _data["centralDisbursedProject"];
            this.centralDisbursedCapital = _data["centralDisbursedCapital"];
            this.districtAssignedCapital = _data["districtAssignedCapital"];
            this.districtAssignedProject = _data["districtAssignedProject"];
            this.districtDisbursedProject = _data["districtDisbursedProject"];
            this.districtDisbursedCapital = _data["districtDisbursedCapital"];
            this.provinceAssignedCapital = _data["provinceAssignedCapital"];
            this.provinceAssignedProject = _data["provinceAssignedProject"];
            this.provinceDisbursedProject = _data["provinceDisbursedProject"];
            this.provinceDisbursedCapital = _data["provinceDisbursedCapital"];
            this.communeAssignedCapital = _data["communeAssignedCapital"];
            this.communeAssignedProject = _data["communeAssignedProject"];
            this.communeDisbursedProject = _data["communeDisbursedProject"];
            this.communeDisbursedCapital = _data["communeDisbursedCapital"];
        }
    }

    static fromJS(data: any): CSDL2bDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL2bDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nationwideAssignedCapital"] = this.nationwideAssignedCapital;
        data["nationwideAssignedProject"] = this.nationwideAssignedProject;
        data["nationwideDisbursedCapital"] = this.nationwideDisbursedCapital;
        data["nationwideDisbursedProject"] = this.nationwideDisbursedProject;
        data["centralAssignedCapital"] = this.centralAssignedCapital;
        data["centralAssignedProject"] = this.centralAssignedProject;
        data["centralDisbursedProject"] = this.centralDisbursedProject;
        data["centralDisbursedCapital"] = this.centralDisbursedCapital;
        data["districtAssignedCapital"] = this.districtAssignedCapital;
        data["districtAssignedProject"] = this.districtAssignedProject;
        data["districtDisbursedProject"] = this.districtDisbursedProject;
        data["districtDisbursedCapital"] = this.districtDisbursedCapital;
        data["provinceAssignedCapital"] = this.provinceAssignedCapital;
        data["provinceAssignedProject"] = this.provinceAssignedProject;
        data["provinceDisbursedProject"] = this.provinceDisbursedProject;
        data["provinceDisbursedCapital"] = this.provinceDisbursedCapital;
        data["communeAssignedCapital"] = this.communeAssignedCapital;
        data["communeAssignedProject"] = this.communeAssignedProject;
        data["communeDisbursedProject"] = this.communeDisbursedProject;
        data["communeDisbursedCapital"] = this.communeDisbursedCapital;
        return data; 
    }

    clone(): CSDL2bDashboard {
        const json = this.toJSON();
        let result = new CSDL2bDashboard();
        result.init(json);
        return result;
    }
}

export interface ICSDL2bDashboard {
    nationwideAssignedCapital: number | undefined;
    nationwideAssignedProject: number | undefined;
    nationwideDisbursedCapital: number | undefined;
    nationwideDisbursedProject: number | undefined;
    centralAssignedCapital: number | undefined;
    centralAssignedProject: number | undefined;
    centralDisbursedProject: number | undefined;
    centralDisbursedCapital: number | undefined;
    districtAssignedCapital: number | undefined;
    districtAssignedProject: number | undefined;
    districtDisbursedProject: number | undefined;
    districtDisbursedCapital: number | undefined;
    provinceAssignedCapital: number | undefined;
    provinceAssignedProject: number | undefined;
    provinceDisbursedProject: number | undefined;
    provinceDisbursedCapital: number | undefined;
    communeAssignedCapital: number | undefined;
    communeAssignedProject: number | undefined;
    communeDisbursedProject: number | undefined;
    communeDisbursedCapital: number | undefined;
}

export class CSDL2bPagedResultDto implements ICSDL2bPagedResultDto {
    items: CSDL2b[] | undefined;
    totalCount: number;

    constructor(data?: ICSDL2bPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CSDL2b.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CSDL2bPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL2bPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CSDL2bPagedResultDto {
        const json = this.toJSON();
        let result = new CSDL2bPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICSDL2bPagedResultDto {
    items: CSDL2b[] | undefined;
    totalCount: number;
}

export class CSDL3a implements ICSDL3a {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    managerCode: string | undefined;
    createdTime: moment.Moment | undefined;

    constructor(data?: ICSDL3a) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.organizationCode = _data["organizationCode"];
            this.programCode = _data["programCode"];
            this.subprojectCode = _data["subprojectCode"];
            this.componentCode = _data["componentCode"];
            this.managerCode = _data["managerCode"];
            this.createdTime = _data["createdTime"] ? moment(_data["createdTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CSDL3a {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL3a();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["organizationCode"] = this.organizationCode;
        data["programCode"] = this.programCode;
        data["subprojectCode"] = this.subprojectCode;
        data["componentCode"] = this.componentCode;
        data["managerCode"] = this.managerCode;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CSDL3a {
        const json = this.toJSON();
        let result = new CSDL3a();
        result.init(json);
        return result;
    }
}

export interface ICSDL3a {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    managerCode: string | undefined;
    createdTime: moment.Moment | undefined;
}

export class CSDL3aChart implements ICSDL3aChart {
    organization: string | undefined;
    assignedMission: number | undefined;
    approvedMission: number | undefined;
    expense: number | undefined;

    constructor(data?: ICSDL3aChart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organization = _data["organization"];
            this.assignedMission = _data["assignedMission"];
            this.approvedMission = _data["approvedMission"];
            this.expense = _data["expense"];
        }
    }

    static fromJS(data: any): CSDL3aChart {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL3aChart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization;
        data["assignedMission"] = this.assignedMission;
        data["approvedMission"] = this.approvedMission;
        data["expense"] = this.expense;
        return data; 
    }

    clone(): CSDL3aChart {
        const json = this.toJSON();
        let result = new CSDL3aChart();
        result.init(json);
        return result;
    }
}

export interface ICSDL3aChart {
    organization: string | undefined;
    assignedMission: number | undefined;
    approvedMission: number | undefined;
    expense: number | undefined;
}

export class CSDL3aDashboard implements ICSDL3aDashboard {
    nationwideAssignedMission: number | undefined;
    nationwideApprovedMission: number | undefined;
    nationwideExpense: number | undefined;
    centralAssignedMission: number | undefined;
    centralApprovedMission: number | undefined;
    centralExpense: number | undefined;
    provinceAssignedMission: number | undefined;
    provinceApprovedMission: number | undefined;
    provinceExpense: number | undefined;
    districtAssignedMission: number | undefined;
    districtApprovedMission: number | undefined;
    districtExpense: number | undefined;
    communeAssignedMission: number | undefined;
    communeApprovedMission: number | undefined;
    communeExpense: number | undefined;

    constructor(data?: ICSDL3aDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nationwideAssignedMission = _data["nationwideAssignedMission"];
            this.nationwideApprovedMission = _data["nationwideApprovedMission"];
            this.nationwideExpense = _data["nationwideExpense"];
            this.centralAssignedMission = _data["centralAssignedMission"];
            this.centralApprovedMission = _data["centralApprovedMission"];
            this.centralExpense = _data["centralExpense"];
            this.provinceAssignedMission = _data["provinceAssignedMission"];
            this.provinceApprovedMission = _data["provinceApprovedMission"];
            this.provinceExpense = _data["provinceExpense"];
            this.districtAssignedMission = _data["districtAssignedMission"];
            this.districtApprovedMission = _data["districtApprovedMission"];
            this.districtExpense = _data["districtExpense"];
            this.communeAssignedMission = _data["communeAssignedMission"];
            this.communeApprovedMission = _data["communeApprovedMission"];
            this.communeExpense = _data["communeExpense"];
        }
    }

    static fromJS(data: any): CSDL3aDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL3aDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nationwideAssignedMission"] = this.nationwideAssignedMission;
        data["nationwideApprovedMission"] = this.nationwideApprovedMission;
        data["nationwideExpense"] = this.nationwideExpense;
        data["centralAssignedMission"] = this.centralAssignedMission;
        data["centralApprovedMission"] = this.centralApprovedMission;
        data["centralExpense"] = this.centralExpense;
        data["provinceAssignedMission"] = this.provinceAssignedMission;
        data["provinceApprovedMission"] = this.provinceApprovedMission;
        data["provinceExpense"] = this.provinceExpense;
        data["districtAssignedMission"] = this.districtAssignedMission;
        data["districtApprovedMission"] = this.districtApprovedMission;
        data["districtExpense"] = this.districtExpense;
        data["communeAssignedMission"] = this.communeAssignedMission;
        data["communeApprovedMission"] = this.communeApprovedMission;
        data["communeExpense"] = this.communeExpense;
        return data; 
    }

    clone(): CSDL3aDashboard {
        const json = this.toJSON();
        let result = new CSDL3aDashboard();
        result.init(json);
        return result;
    }
}

export interface ICSDL3aDashboard {
    nationwideAssignedMission: number | undefined;
    nationwideApprovedMission: number | undefined;
    nationwideExpense: number | undefined;
    centralAssignedMission: number | undefined;
    centralApprovedMission: number | undefined;
    centralExpense: number | undefined;
    provinceAssignedMission: number | undefined;
    provinceApprovedMission: number | undefined;
    provinceExpense: number | undefined;
    districtAssignedMission: number | undefined;
    districtApprovedMission: number | undefined;
    districtExpense: number | undefined;
    communeAssignedMission: number | undefined;
    communeApprovedMission: number | undefined;
    communeExpense: number | undefined;
}

export class CSDL3aPagedResultDto implements ICSDL3aPagedResultDto {
    items: CSDL3a[] | undefined;
    totalCount: number;

    constructor(data?: ICSDL3aPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CSDL3a.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CSDL3aPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL3aPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CSDL3aPagedResultDto {
        const json = this.toJSON();
        let result = new CSDL3aPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICSDL3aPagedResultDto {
    items: CSDL3a[] | undefined;
    totalCount: number;
}

export class CSDL3b implements ICSDL3b {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    missionCode: string | undefined;
    implementationProgress: string | undefined;
    managerCode: string | undefined;
    createdTime: moment.Moment | undefined;

    constructor(data?: ICSDL3b) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.organizationCode = _data["organizationCode"];
            this.programCode = _data["programCode"];
            this.subprojectCode = _data["subprojectCode"];
            this.componentCode = _data["componentCode"];
            this.missionCode = _data["missionCode"];
            this.implementationProgress = _data["implementationProgress"];
            this.managerCode = _data["managerCode"];
            this.createdTime = _data["createdTime"] ? moment(_data["createdTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CSDL3b {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL3b();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["organizationCode"] = this.organizationCode;
        data["programCode"] = this.programCode;
        data["subprojectCode"] = this.subprojectCode;
        data["componentCode"] = this.componentCode;
        data["missionCode"] = this.missionCode;
        data["implementationProgress"] = this.implementationProgress;
        data["managerCode"] = this.managerCode;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CSDL3b {
        const json = this.toJSON();
        let result = new CSDL3b();
        result.init(json);
        return result;
    }
}

export interface ICSDL3b {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    missionCode: string | undefined;
    implementationProgress: string | undefined;
    managerCode: string | undefined;
    createdTime: moment.Moment | undefined;
}

export class CSDL3bChart implements ICSDL3bChart {
    organization: string | undefined;
    assignedCapital: number | undefined;
    disbursedCapital: number | undefined;

    constructor(data?: ICSDL3bChart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organization = _data["organization"];
            this.assignedCapital = _data["assignedCapital"];
            this.disbursedCapital = _data["disbursedCapital"];
        }
    }

    static fromJS(data: any): CSDL3bChart {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL3bChart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization;
        data["assignedCapital"] = this.assignedCapital;
        data["disbursedCapital"] = this.disbursedCapital;
        return data; 
    }

    clone(): CSDL3bChart {
        const json = this.toJSON();
        let result = new CSDL3bChart();
        result.init(json);
        return result;
    }
}

export interface ICSDL3bChart {
    organization: string | undefined;
    assignedCapital: number | undefined;
    disbursedCapital: number | undefined;
}

export class CSDL3bDashboard implements ICSDL3bDashboard {
    nationwideAssignedCapital: number | undefined;
    nationwideDisbursedCapital: number | undefined;
    centralAssignedCapital: number | undefined;
    centralDisbursedCapital: number | undefined;
    provinceAssignedCapital: number | undefined;
    provinceDisbursedCapital: number | undefined;
    districtAssignedCapital: number | undefined;
    districtDisbursedCapital: number | undefined;
    communeAssignedCapital: number | undefined;
    communeDisbursedCapital: number | undefined;

    constructor(data?: ICSDL3bDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nationwideAssignedCapital = _data["nationwideAssignedCapital"];
            this.nationwideDisbursedCapital = _data["nationwideDisbursedCapital"];
            this.centralAssignedCapital = _data["centralAssignedCapital"];
            this.centralDisbursedCapital = _data["centralDisbursedCapital"];
            this.provinceAssignedCapital = _data["provinceAssignedCapital"];
            this.provinceDisbursedCapital = _data["provinceDisbursedCapital"];
            this.districtAssignedCapital = _data["districtAssignedCapital"];
            this.districtDisbursedCapital = _data["districtDisbursedCapital"];
            this.communeAssignedCapital = _data["communeAssignedCapital"];
            this.communeDisbursedCapital = _data["communeDisbursedCapital"];
        }
    }

    static fromJS(data: any): CSDL3bDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL3bDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nationwideAssignedCapital"] = this.nationwideAssignedCapital;
        data["nationwideDisbursedCapital"] = this.nationwideDisbursedCapital;
        data["centralAssignedCapital"] = this.centralAssignedCapital;
        data["centralDisbursedCapital"] = this.centralDisbursedCapital;
        data["provinceAssignedCapital"] = this.provinceAssignedCapital;
        data["provinceDisbursedCapital"] = this.provinceDisbursedCapital;
        data["districtAssignedCapital"] = this.districtAssignedCapital;
        data["districtDisbursedCapital"] = this.districtDisbursedCapital;
        data["communeAssignedCapital"] = this.communeAssignedCapital;
        data["communeDisbursedCapital"] = this.communeDisbursedCapital;
        return data; 
    }

    clone(): CSDL3bDashboard {
        const json = this.toJSON();
        let result = new CSDL3bDashboard();
        result.init(json);
        return result;
    }
}

export interface ICSDL3bDashboard {
    nationwideAssignedCapital: number | undefined;
    nationwideDisbursedCapital: number | undefined;
    centralAssignedCapital: number | undefined;
    centralDisbursedCapital: number | undefined;
    provinceAssignedCapital: number | undefined;
    provinceDisbursedCapital: number | undefined;
    districtAssignedCapital: number | undefined;
    districtDisbursedCapital: number | undefined;
    communeAssignedCapital: number | undefined;
    communeDisbursedCapital: number | undefined;
}

export class CSDL3bPagedResultDto implements ICSDL3bPagedResultDto {
    items: CSDL3b[] | undefined;
    totalCount: number;

    constructor(data?: ICSDL3bPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CSDL3b.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CSDL3bPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL3bPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CSDL3bPagedResultDto {
        const json = this.toJSON();
        let result = new CSDL3bPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICSDL3bPagedResultDto {
    items: CSDL3b[] | undefined;
    totalCount: number;
}

export class CSDL4a implements ICSDL4a {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    projectCode: string | undefined;
    implementationProgress: string | undefined;
    managerCode: string | undefined;
    totalInvestment: number | undefined;
    capitalAmount: number | undefined;
    settlementProposal: number | undefined;
    settled: number | undefined;
    createdTime: moment.Moment | undefined;

    constructor(data?: ICSDL4a) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.organizationCode = _data["organizationCode"];
            this.programCode = _data["programCode"];
            this.subprojectCode = _data["subprojectCode"];
            this.componentCode = _data["componentCode"];
            this.projectCode = _data["projectCode"];
            this.implementationProgress = _data["implementationProgress"];
            this.managerCode = _data["managerCode"];
            this.totalInvestment = _data["totalInvestment"];
            this.capitalAmount = _data["capitalAmount"];
            this.settlementProposal = _data["settlementProposal"];
            this.settled = _data["settled"];
            this.createdTime = _data["createdTime"] ? moment(_data["createdTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CSDL4a {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL4a();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["organizationCode"] = this.organizationCode;
        data["programCode"] = this.programCode;
        data["subprojectCode"] = this.subprojectCode;
        data["componentCode"] = this.componentCode;
        data["projectCode"] = this.projectCode;
        data["implementationProgress"] = this.implementationProgress;
        data["managerCode"] = this.managerCode;
        data["totalInvestment"] = this.totalInvestment;
        data["capitalAmount"] = this.capitalAmount;
        data["settlementProposal"] = this.settlementProposal;
        data["settled"] = this.settled;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CSDL4a {
        const json = this.toJSON();
        let result = new CSDL4a();
        result.init(json);
        return result;
    }
}

export interface ICSDL4a {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    projectCode: string | undefined;
    implementationProgress: string | undefined;
    managerCode: string | undefined;
    totalInvestment: number | undefined;
    capitalAmount: number | undefined;
    settlementProposal: number | undefined;
    settled: number | undefined;
    createdTime: moment.Moment | undefined;
}

export class CSDL4aChart implements ICSDL4aChart {
    organization: string | undefined;
    pendingProject: number | undefined;
    approvedProject: number | undefined;
    pendingAmount: number | undefined;
    approvedAmount: number | undefined;

    constructor(data?: ICSDL4aChart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organization = _data["organization"];
            this.pendingProject = _data["pendingProject"];
            this.approvedProject = _data["approvedProject"];
            this.pendingAmount = _data["pendingAmount"];
            this.approvedAmount = _data["approvedAmount"];
        }
    }

    static fromJS(data: any): CSDL4aChart {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL4aChart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization;
        data["pendingProject"] = this.pendingProject;
        data["approvedProject"] = this.approvedProject;
        data["pendingAmount"] = this.pendingAmount;
        data["approvedAmount"] = this.approvedAmount;
        return data; 
    }

    clone(): CSDL4aChart {
        const json = this.toJSON();
        let result = new CSDL4aChart();
        result.init(json);
        return result;
    }
}

export interface ICSDL4aChart {
    organization: string | undefined;
    pendingProject: number | undefined;
    approvedProject: number | undefined;
    pendingAmount: number | undefined;
    approvedAmount: number | undefined;
}

export class CSDL4aDashboard implements ICSDL4aDashboard {
    nationwidePendingProject: number | undefined;
    nationwideApprovedProject: number | undefined;
    nationwidePendingAmount: number | undefined;
    nationwideApprovedAmount: number | undefined;
    centralPendingProject: number | undefined;
    centralApprovedProject: number | undefined;
    centralPendingAmount: number | undefined;
    centralApprovedAmount: number | undefined;
    provincePendingProject: number | undefined;
    provinceApprovedProject: number | undefined;
    provincePendingAmount: number | undefined;
    provinceApprovedAmount: number | undefined;
    districtPendingProject: number | undefined;
    districtApprovedProject: number | undefined;
    districtPendingAmount: number | undefined;
    districtApprovedAmount: number | undefined;
    communePendingProject: number | undefined;
    communeApprovedProject: number | undefined;
    communePendingAmount: number | undefined;
    communeApprovedAmount: number | undefined;

    constructor(data?: ICSDL4aDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nationwidePendingProject = _data["nationwidePendingProject"];
            this.nationwideApprovedProject = _data["nationwideApprovedProject"];
            this.nationwidePendingAmount = _data["nationwidePendingAmount"];
            this.nationwideApprovedAmount = _data["nationwideApprovedAmount"];
            this.centralPendingProject = _data["centralPendingProject"];
            this.centralApprovedProject = _data["centralApprovedProject"];
            this.centralPendingAmount = _data["centralPendingAmount"];
            this.centralApprovedAmount = _data["centralApprovedAmount"];
            this.provincePendingProject = _data["provincePendingProject"];
            this.provinceApprovedProject = _data["provinceApprovedProject"];
            this.provincePendingAmount = _data["provincePendingAmount"];
            this.provinceApprovedAmount = _data["provinceApprovedAmount"];
            this.districtPendingProject = _data["districtPendingProject"];
            this.districtApprovedProject = _data["districtApprovedProject"];
            this.districtPendingAmount = _data["districtPendingAmount"];
            this.districtApprovedAmount = _data["districtApprovedAmount"];
            this.communePendingProject = _data["communePendingProject"];
            this.communeApprovedProject = _data["communeApprovedProject"];
            this.communePendingAmount = _data["communePendingAmount"];
            this.communeApprovedAmount = _data["communeApprovedAmount"];
        }
    }

    static fromJS(data: any): CSDL4aDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL4aDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nationwidePendingProject"] = this.nationwidePendingProject;
        data["nationwideApprovedProject"] = this.nationwideApprovedProject;
        data["nationwidePendingAmount"] = this.nationwidePendingAmount;
        data["nationwideApprovedAmount"] = this.nationwideApprovedAmount;
        data["centralPendingProject"] = this.centralPendingProject;
        data["centralApprovedProject"] = this.centralApprovedProject;
        data["centralPendingAmount"] = this.centralPendingAmount;
        data["centralApprovedAmount"] = this.centralApprovedAmount;
        data["provincePendingProject"] = this.provincePendingProject;
        data["provinceApprovedProject"] = this.provinceApprovedProject;
        data["provincePendingAmount"] = this.provincePendingAmount;
        data["provinceApprovedAmount"] = this.provinceApprovedAmount;
        data["districtPendingProject"] = this.districtPendingProject;
        data["districtApprovedProject"] = this.districtApprovedProject;
        data["districtPendingAmount"] = this.districtPendingAmount;
        data["districtApprovedAmount"] = this.districtApprovedAmount;
        data["communePendingProject"] = this.communePendingProject;
        data["communeApprovedProject"] = this.communeApprovedProject;
        data["communePendingAmount"] = this.communePendingAmount;
        data["communeApprovedAmount"] = this.communeApprovedAmount;
        return data; 
    }

    clone(): CSDL4aDashboard {
        const json = this.toJSON();
        let result = new CSDL4aDashboard();
        result.init(json);
        return result;
    }
}

export interface ICSDL4aDashboard {
    nationwidePendingProject: number | undefined;
    nationwideApprovedProject: number | undefined;
    nationwidePendingAmount: number | undefined;
    nationwideApprovedAmount: number | undefined;
    centralPendingProject: number | undefined;
    centralApprovedProject: number | undefined;
    centralPendingAmount: number | undefined;
    centralApprovedAmount: number | undefined;
    provincePendingProject: number | undefined;
    provinceApprovedProject: number | undefined;
    provincePendingAmount: number | undefined;
    provinceApprovedAmount: number | undefined;
    districtPendingProject: number | undefined;
    districtApprovedProject: number | undefined;
    districtPendingAmount: number | undefined;
    districtApprovedAmount: number | undefined;
    communePendingProject: number | undefined;
    communeApprovedProject: number | undefined;
    communePendingAmount: number | undefined;
    communeApprovedAmount: number | undefined;
}

export class CSDL4aPagedResultDto implements ICSDL4aPagedResultDto {
    items: CSDL4a[] | undefined;
    totalCount: number;

    constructor(data?: ICSDL4aPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CSDL4a.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CSDL4aPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL4aPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CSDL4aPagedResultDto {
        const json = this.toJSON();
        let result = new CSDL4aPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICSDL4aPagedResultDto {
    items: CSDL4a[] | undefined;
    totalCount: number;
}

export class CSDL4b implements ICSDL4b {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    projectCode: string | undefined;
    implementationProgress: string | undefined;
    managerCode: string | undefined;
    yearEstimatesAssigned: number | undefined;
    completedValue: number | undefined;
    fixedAssetFormation: number | undefined;
    settlementProposal: number | undefined;
    settled: number | undefined;
    createdTime: moment.Moment | undefined;

    constructor(data?: ICSDL4b) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.organizationCode = _data["organizationCode"];
            this.programCode = _data["programCode"];
            this.subprojectCode = _data["subprojectCode"];
            this.componentCode = _data["componentCode"];
            this.projectCode = _data["projectCode"];
            this.implementationProgress = _data["implementationProgress"];
            this.managerCode = _data["managerCode"];
            this.yearEstimatesAssigned = _data["yearEstimatesAssigned"];
            this.completedValue = _data["completedValue"];
            this.fixedAssetFormation = _data["fixedAssetFormation"];
            this.settlementProposal = _data["settlementProposal"];
            this.settled = _data["settled"];
            this.createdTime = _data["createdTime"] ? moment(_data["createdTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CSDL4b {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL4b();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["organizationCode"] = this.organizationCode;
        data["programCode"] = this.programCode;
        data["subprojectCode"] = this.subprojectCode;
        data["componentCode"] = this.componentCode;
        data["projectCode"] = this.projectCode;
        data["implementationProgress"] = this.implementationProgress;
        data["managerCode"] = this.managerCode;
        data["yearEstimatesAssigned"] = this.yearEstimatesAssigned;
        data["completedValue"] = this.completedValue;
        data["fixedAssetFormation"] = this.fixedAssetFormation;
        data["settlementProposal"] = this.settlementProposal;
        data["settled"] = this.settled;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CSDL4b {
        const json = this.toJSON();
        let result = new CSDL4b();
        result.init(json);
        return result;
    }
}

export interface ICSDL4b {
    id: number;
    code: string | undefined;
    organizationCode: string | undefined;
    programCode: string | undefined;
    subprojectCode: string | undefined;
    componentCode: string | undefined;
    projectCode: string | undefined;
    implementationProgress: string | undefined;
    managerCode: string | undefined;
    yearEstimatesAssigned: number | undefined;
    completedValue: number | undefined;
    fixedAssetFormation: number | undefined;
    settlementProposal: number | undefined;
    settled: number | undefined;
    createdTime: moment.Moment | undefined;
}

export class CSDL4bChart implements ICSDL4bChart {
    organization: string | undefined;
    pendingMission: number | undefined;
    approvedMission: number | undefined;
    pendingExpense: number | undefined;
    approvedExpense: number | undefined;

    constructor(data?: ICSDL4bChart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organization = _data["organization"];
            this.pendingMission = _data["pendingMission"];
            this.approvedMission = _data["approvedMission"];
            this.pendingExpense = _data["pendingExpense"];
            this.approvedExpense = _data["approvedExpense"];
        }
    }

    static fromJS(data: any): CSDL4bChart {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL4bChart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization;
        data["pendingMission"] = this.pendingMission;
        data["approvedMission"] = this.approvedMission;
        data["pendingExpense"] = this.pendingExpense;
        data["approvedExpense"] = this.approvedExpense;
        return data; 
    }

    clone(): CSDL4bChart {
        const json = this.toJSON();
        let result = new CSDL4bChart();
        result.init(json);
        return result;
    }
}

export interface ICSDL4bChart {
    organization: string | undefined;
    pendingMission: number | undefined;
    approvedMission: number | undefined;
    pendingExpense: number | undefined;
    approvedExpense: number | undefined;
}

export class CSDL4bDashboard implements ICSDL4bDashboard {
    nationwidePendingMission: number | undefined;
    nationwideApprovedMission: number | undefined;
    nationwidePendingExpense: number | undefined;
    nationwideApprovedExpense: number | undefined;
    centralPendingMission: number | undefined;
    centralApprovedMission: number | undefined;
    centralPendingExpense: number | undefined;
    centralApprovedExpense: number | undefined;
    provincePendingMission: number | undefined;
    provinceApprovedMission: number | undefined;
    provincePendingExpense: number | undefined;
    provinceApprovedExpense: number | undefined;
    districtPendingMission: number | undefined;
    districtApprovedMission: number | undefined;
    districtPendingExpense: number | undefined;
    districtApprovedExpense: number | undefined;
    communePendingMission: number | undefined;
    communeApprovedMission: number | undefined;
    communePendingExpense: number | undefined;
    communeApprovedExpense: number | undefined;

    constructor(data?: ICSDL4bDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nationwidePendingMission = _data["nationwidePendingMission"];
            this.nationwideApprovedMission = _data["nationwideApprovedMission"];
            this.nationwidePendingExpense = _data["nationwidePendingExpense"];
            this.nationwideApprovedExpense = _data["nationwideApprovedExpense"];
            this.centralPendingMission = _data["centralPendingMission"];
            this.centralApprovedMission = _data["centralApprovedMission"];
            this.centralPendingExpense = _data["centralPendingExpense"];
            this.centralApprovedExpense = _data["centralApprovedExpense"];
            this.provincePendingMission = _data["provincePendingMission"];
            this.provinceApprovedMission = _data["provinceApprovedMission"];
            this.provincePendingExpense = _data["provincePendingExpense"];
            this.provinceApprovedExpense = _data["provinceApprovedExpense"];
            this.districtPendingMission = _data["districtPendingMission"];
            this.districtApprovedMission = _data["districtApprovedMission"];
            this.districtPendingExpense = _data["districtPendingExpense"];
            this.districtApprovedExpense = _data["districtApprovedExpense"];
            this.communePendingMission = _data["communePendingMission"];
            this.communeApprovedMission = _data["communeApprovedMission"];
            this.communePendingExpense = _data["communePendingExpense"];
            this.communeApprovedExpense = _data["communeApprovedExpense"];
        }
    }

    static fromJS(data: any): CSDL4bDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL4bDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nationwidePendingMission"] = this.nationwidePendingMission;
        data["nationwideApprovedMission"] = this.nationwideApprovedMission;
        data["nationwidePendingExpense"] = this.nationwidePendingExpense;
        data["nationwideApprovedExpense"] = this.nationwideApprovedExpense;
        data["centralPendingMission"] = this.centralPendingMission;
        data["centralApprovedMission"] = this.centralApprovedMission;
        data["centralPendingExpense"] = this.centralPendingExpense;
        data["centralApprovedExpense"] = this.centralApprovedExpense;
        data["provincePendingMission"] = this.provincePendingMission;
        data["provinceApprovedMission"] = this.provinceApprovedMission;
        data["provincePendingExpense"] = this.provincePendingExpense;
        data["provinceApprovedExpense"] = this.provinceApprovedExpense;
        data["districtPendingMission"] = this.districtPendingMission;
        data["districtApprovedMission"] = this.districtApprovedMission;
        data["districtPendingExpense"] = this.districtPendingExpense;
        data["districtApprovedExpense"] = this.districtApprovedExpense;
        data["communePendingMission"] = this.communePendingMission;
        data["communeApprovedMission"] = this.communeApprovedMission;
        data["communePendingExpense"] = this.communePendingExpense;
        data["communeApprovedExpense"] = this.communeApprovedExpense;
        return data; 
    }

    clone(): CSDL4bDashboard {
        const json = this.toJSON();
        let result = new CSDL4bDashboard();
        result.init(json);
        return result;
    }
}

export interface ICSDL4bDashboard {
    nationwidePendingMission: number | undefined;
    nationwideApprovedMission: number | undefined;
    nationwidePendingExpense: number | undefined;
    nationwideApprovedExpense: number | undefined;
    centralPendingMission: number | undefined;
    centralApprovedMission: number | undefined;
    centralPendingExpense: number | undefined;
    centralApprovedExpense: number | undefined;
    provincePendingMission: number | undefined;
    provinceApprovedMission: number | undefined;
    provincePendingExpense: number | undefined;
    provinceApprovedExpense: number | undefined;
    districtPendingMission: number | undefined;
    districtApprovedMission: number | undefined;
    districtPendingExpense: number | undefined;
    districtApprovedExpense: number | undefined;
    communePendingMission: number | undefined;
    communeApprovedMission: number | undefined;
    communePendingExpense: number | undefined;
    communeApprovedExpense: number | undefined;
}

export class CSDL4bPagedResultDto implements ICSDL4bPagedResultDto {
    items: CSDL4b[] | undefined;
    totalCount: number;

    constructor(data?: ICSDL4bPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CSDL4b.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CSDL4bPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CSDL4bPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CSDL4bPagedResultDto {
        const json = this.toJSON();
        let result = new CSDL4bPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICSDL4bPagedResultDto {
    items: CSDL4b[] | undefined;
    totalCount: number;
}

export class ChangePasswordAccDto implements IChangePasswordAccDto {
    newPassword: string;
    key: string | undefined;

    constructor(data?: IChangePasswordAccDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): ChangePasswordAccDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordAccDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        data["key"] = this.key;
        return data; 
    }

    clone(): ChangePasswordAccDto {
        const json = this.toJSON();
        let result = new ChangePasswordAccDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordAccDto {
    newPassword: string;
    key: string | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChucDanh implements IChucDanh {
    id: number;
    tenChucDanh: string | undefined;
    isDelete: boolean;

    constructor(data?: IChucDanh) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenChucDanh = _data["tenChucDanh"];
            this.isDelete = _data["isDelete"];
        }
    }

    static fromJS(data: any): ChucDanh {
        data = typeof data === 'object' ? data : {};
        let result = new ChucDanh();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenChucDanh"] = this.tenChucDanh;
        data["isDelete"] = this.isDelete;
        return data; 
    }

    clone(): ChucDanh {
        const json = this.toJSON();
        let result = new ChucDanh();
        result.init(json);
        return result;
    }
}

export interface IChucDanh {
    id: number;
    tenChucDanh: string | undefined;
    isDelete: boolean;
}

export class ChucDanhInputDto implements IChucDanhInputDto {
    id: number;
    tenChucDanh: string | undefined;

    constructor(data?: IChucDanhInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenChucDanh = _data["tenChucDanh"];
        }
    }

    static fromJS(data: any): ChucDanhInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChucDanhInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenChucDanh"] = this.tenChucDanh;
        return data; 
    }

    clone(): ChucDanhInputDto {
        const json = this.toJSON();
        let result = new ChucDanhInputDto();
        result.init(json);
        return result;
    }
}

export interface IChucDanhInputDto {
    id: number;
    tenChucDanh: string | undefined;
}

export class ChucDanhPagedResultDto implements IChucDanhPagedResultDto {
    items: ChucDanh[] | undefined;
    totalCount: number;

    constructor(data?: IChucDanhPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ChucDanh.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ChucDanhPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChucDanhPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ChucDanhPagedResultDto {
        const json = this.toJSON();
        let result = new ChucDanhPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IChucDanhPagedResultDto {
    items: ChucDanh[] | undefined;
    totalCount: number;
}

export class Config implements IConfig {
    id: number;
    keyConfig: string | undefined;
    vauleConfig: string | undefined;

    constructor(data?: IConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.keyConfig = _data["keyConfig"];
            this.vauleConfig = _data["vauleConfig"];
        }
    }

    static fromJS(data: any): Config {
        data = typeof data === 'object' ? data : {};
        let result = new Config();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["keyConfig"] = this.keyConfig;
        data["vauleConfig"] = this.vauleConfig;
        return data; 
    }

    clone(): Config {
        const json = this.toJSON();
        let result = new Config();
        result.init(json);
        return result;
    }
}

export interface IConfig {
    id: number;
    keyConfig: string | undefined;
    vauleConfig: string | undefined;
}

export class ConfigInputDto implements IConfigInputDto {
    id: number;
    keyConfig: string | undefined;
    vauleConfig: string | undefined;

    constructor(data?: IConfigInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.keyConfig = _data["keyConfig"];
            this.vauleConfig = _data["vauleConfig"];
        }
    }

    static fromJS(data: any): ConfigInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["keyConfig"] = this.keyConfig;
        data["vauleConfig"] = this.vauleConfig;
        return data; 
    }

    clone(): ConfigInputDto {
        const json = this.toJSON();
        let result = new ConfigInputDto();
        result.init(json);
        return result;
    }
}

export interface IConfigInputDto {
    id: number;
    keyConfig: string | undefined;
    vauleConfig: string | undefined;
}

export class Coordinate implements ICoordinate {
    x: number;
    y: number;
    z: number;
    m: number;
    coordinateValue: Coordinate;

    constructor(data?: ICoordinate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
            this.z = _data["z"];
            this.m = _data["m"];
            this.coordinateValue = _data["coordinateValue"] ? Coordinate.fromJS(_data["coordinateValue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Coordinate {
        data = typeof data === 'object' ? data : {};
        let result = new Coordinate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        data["z"] = this.z;
        data["m"] = this.m;
        data["coordinateValue"] = this.coordinateValue ? this.coordinateValue.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Coordinate {
        const json = this.toJSON();
        let result = new Coordinate();
        result.init(json);
        return result;
    }
}

export interface ICoordinate {
    x: number;
    y: number;
    z: number;
    m: number;
    coordinateValue: Coordinate;
}

export class CoordinateSequence implements ICoordinateSequence {
    readonly dimension: number;
    readonly measures: number;
    readonly spatial: number;
    ordinates: Ordinates;
    readonly hasZ: boolean;
    readonly hasM: boolean;
    readonly zOrdinateIndex: number;
    readonly mOrdinateIndex: number;
    readonly count: number;

    constructor(data?: ICoordinateSequence) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).dimension = _data["dimension"];
            (<any>this).measures = _data["measures"];
            (<any>this).spatial = _data["spatial"];
            this.ordinates = _data["ordinates"];
            (<any>this).hasZ = _data["hasZ"];
            (<any>this).hasM = _data["hasM"];
            (<any>this).zOrdinateIndex = _data["zOrdinateIndex"];
            (<any>this).mOrdinateIndex = _data["mOrdinateIndex"];
            (<any>this).count = _data["count"];
        }
    }

    static fromJS(data: any): CoordinateSequence {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinateSequence();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dimension"] = this.dimension;
        data["measures"] = this.measures;
        data["spatial"] = this.spatial;
        data["ordinates"] = this.ordinates;
        data["hasZ"] = this.hasZ;
        data["hasM"] = this.hasM;
        data["zOrdinateIndex"] = this.zOrdinateIndex;
        data["mOrdinateIndex"] = this.mOrdinateIndex;
        data["count"] = this.count;
        return data; 
    }

    clone(): CoordinateSequence {
        const json = this.toJSON();
        let result = new CoordinateSequence();
        result.init(json);
        return result;
    }
}

export interface ICoordinateSequence {
    dimension: number;
    measures: number;
    spatial: number;
    ordinates: Ordinates;
    hasZ: boolean;
    hasM: boolean;
    zOrdinateIndex: number;
    mOrdinateIndex: number;
    count: number;
}

export class CoordinateSequenceFactory implements ICoordinateSequenceFactory {
    ordinates: Ordinates;

    constructor(data?: ICoordinateSequenceFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ordinates = _data["ordinates"];
        }
    }

    static fromJS(data: any): CoordinateSequenceFactory {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinateSequenceFactory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ordinates"] = this.ordinates;
        return data; 
    }

    clone(): CoordinateSequenceFactory {
        const json = this.toJSON();
        let result = new CoordinateSequenceFactory();
        result.init(json);
        return result;
    }
}

export interface ICoordinateSequenceFactory {
    ordinates: Ordinates;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    id: number;
    tenantId: number;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    isDeleted: boolean;
    diaBanId: number | undefined;
    address: string | undefined;
    orgCode: string | undefined;
    maTinh: string | undefined;
    maHuyen: string | undefined;
    maXa: string | undefined;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.isDeleted = _data["isDeleted"];
            this.diaBanId = _data["diaBanId"];
            this.address = _data["address"];
            this.orgCode = _data["orgCode"];
            this.maTinh = _data["maTinh"];
            this.maHuyen = _data["maHuyen"];
            this.maXa = _data["maXa"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["isDeleted"] = this.isDeleted;
        data["diaBanId"] = this.diaBanId;
        data["address"] = this.address;
        data["orgCode"] = this.orgCode;
        data["maTinh"] = this.maTinh;
        data["maHuyen"] = this.maHuyen;
        data["maXa"] = this.maXa;
        return data; 
    }

    clone(): CreateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new CreateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationUnitInput {
    id: number;
    tenantId: number;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    isDeleted: boolean;
    diaBanId: number | undefined;
    address: string | undefined;
    orgCode: string | undefined;
    maTinh: string | undefined;
    maHuyen: string | undefined;
    maXa: string | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class CreateUserDVHCDto implements ICreateUserDVHCDto {
    listUserId: number[] | undefined;
    id_DVHC: string | undefined;
    dvhC_MaHuyen: string | undefined;
    dvhC_MaTinh: string | undefined;
    dvhC_MaXa: string | undefined;
    ma_dvhc_t: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_x: string | undefined;
    isChecked: boolean;

    constructor(data?: ICreateUserDVHCDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listUserId"])) {
                this.listUserId = [] as any;
                for (let item of _data["listUserId"])
                    this.listUserId.push(item);
            }
            this.id_DVHC = _data["id_DVHC"];
            this.dvhC_MaHuyen = _data["dvhC_MaHuyen"];
            this.dvhC_MaTinh = _data["dvhC_MaTinh"];
            this.dvhC_MaXa = _data["dvhC_MaXa"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
            this.ma_dvhc_h = _data["ma_dvhc_h"];
            this.ma_dvhc_x = _data["ma_dvhc_x"];
            this.isChecked = _data["isChecked"];
        }
    }

    static fromJS(data: any): CreateUserDVHCDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDVHCDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listUserId)) {
            data["listUserId"] = [];
            for (let item of this.listUserId)
                data["listUserId"].push(item);
        }
        data["id_DVHC"] = this.id_DVHC;
        data["dvhC_MaHuyen"] = this.dvhC_MaHuyen;
        data["dvhC_MaTinh"] = this.dvhC_MaTinh;
        data["dvhC_MaXa"] = this.dvhC_MaXa;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        data["ma_dvhc_h"] = this.ma_dvhc_h;
        data["ma_dvhc_x"] = this.ma_dvhc_x;
        data["isChecked"] = this.isChecked;
        return data; 
    }

    clone(): CreateUserDVHCDto {
        const json = this.toJSON();
        let result = new CreateUserDVHCDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDVHCDto {
    listUserId: number[] | undefined;
    id_DVHC: string | undefined;
    dvhC_MaHuyen: string | undefined;
    dvhC_MaTinh: string | undefined;
    dvhC_MaXa: string | undefined;
    ma_dvhc_t: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_x: string | undefined;
    isChecked: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    userOrg: string[] | undefined;
    phoneNumber: string | undefined;
    password: string;
    toChuc: OrganizationUnit[] | undefined;
    fullName: string | undefined;
    address: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    avatar: string | undefined;
    chucDanhId: number | undefined;
    tenChucDanh: string | undefined;
    ngayCap: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            if (Array.isArray(_data["userOrg"])) {
                this.userOrg = [] as any;
                for (let item of _data["userOrg"])
                    this.userOrg.push(item);
            }
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            if (Array.isArray(_data["toChuc"])) {
                this.toChuc = [] as any;
                for (let item of _data["toChuc"])
                    this.toChuc.push(OrganizationUnit.fromJS(item));
            }
            this.fullName = _data["fullName"];
            this.address = _data["address"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.avatar = _data["avatar"];
            this.chucDanhId = _data["chucDanhId"];
            this.tenChucDanh = _data["tenChucDanh"];
            this.ngayCap = _data["ngayCap"] ? moment(_data["ngayCap"].toString()) : <any>undefined;
            this.ngayHetHan = _data["ngayHetHan"] ? moment(_data["ngayHetHan"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.userOrg)) {
            data["userOrg"] = [];
            for (let item of this.userOrg)
                data["userOrg"].push(item);
        }
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        if (Array.isArray(this.toChuc)) {
            data["toChuc"] = [];
            for (let item of this.toChuc)
                data["toChuc"].push(item.toJSON());
        }
        data["fullName"] = this.fullName;
        data["address"] = this.address;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["avatar"] = this.avatar;
        data["chucDanhId"] = this.chucDanhId;
        data["tenChucDanh"] = this.tenChucDanh;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    userOrg: string[] | undefined;
    phoneNumber: string | undefined;
    password: string;
    toChuc: OrganizationUnit[] | undefined;
    fullName: string | undefined;
    address: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    avatar: string | undefined;
    chucDanhId: number | undefined;
    tenChucDanh: string | undefined;
    ngayCap: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;
}

export class DTODuyetPAKN implements IDTODuyetPAKN {
    id: number;
    title: string | undefined;
    content: string | undefined;
    paTime: string | undefined;
    creationTime: string | undefined;
    kienNghi: string | undefined;
    userSendId: number;
    state: number;
    tenDoiTuong: string | undefined;
    stateName: string | undefined;
    noiDungPheDuyet: string | undefined;
    tenToChuc: string | undefined;
    userSendName: string | undefined;

    constructor(data?: IDTODuyetPAKN) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.paTime = _data["paTime"];
            this.creationTime = _data["creationTime"];
            this.kienNghi = _data["kienNghi"];
            this.userSendId = _data["userSendId"];
            this.state = _data["state"];
            this.tenDoiTuong = _data["tenDoiTuong"];
            this.stateName = _data["stateName"];
            this.noiDungPheDuyet = _data["noiDungPheDuyet"];
            this.tenToChuc = _data["tenToChuc"];
            this.userSendName = _data["userSendName"];
        }
    }

    static fromJS(data: any): DTODuyetPAKN {
        data = typeof data === 'object' ? data : {};
        let result = new DTODuyetPAKN();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["paTime"] = this.paTime;
        data["creationTime"] = this.creationTime;
        data["kienNghi"] = this.kienNghi;
        data["userSendId"] = this.userSendId;
        data["state"] = this.state;
        data["tenDoiTuong"] = this.tenDoiTuong;
        data["stateName"] = this.stateName;
        data["noiDungPheDuyet"] = this.noiDungPheDuyet;
        data["tenToChuc"] = this.tenToChuc;
        data["userSendName"] = this.userSendName;
        return data; 
    }

    clone(): DTODuyetPAKN {
        const json = this.toJSON();
        let result = new DTODuyetPAKN();
        result.init(json);
        return result;
    }
}

export interface IDTODuyetPAKN {
    id: number;
    title: string | undefined;
    content: string | undefined;
    paTime: string | undefined;
    creationTime: string | undefined;
    kienNghi: string | undefined;
    userSendId: number;
    state: number;
    tenDoiTuong: string | undefined;
    stateName: string | undefined;
    noiDungPheDuyet: string | undefined;
    tenToChuc: string | undefined;
    userSendName: string | undefined;
}

export class DTODuyetPAKNPagedResultDto implements IDTODuyetPAKNPagedResultDto {
    items: DTODuyetPAKN[] | undefined;
    totalCount: number;

    constructor(data?: IDTODuyetPAKNPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DTODuyetPAKN.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DTODuyetPAKNPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DTODuyetPAKNPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DTODuyetPAKNPagedResultDto {
        const json = this.toJSON();
        let result = new DTODuyetPAKNPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDTODuyetPAKNPagedResultDto {
    items: DTODuyetPAKN[] | undefined;
    totalCount: number;
}

export class DTOMaTinhHuyenXa implements IDTOMaTinhHuyenXa {
    ma_dvhc_t: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_x: string | undefined;

    constructor(data?: IDTOMaTinhHuyenXa) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma_dvhc_t = _data["ma_dvhc_t"];
            this.ma_dvhc_h = _data["ma_dvhc_h"];
            this.ma_dvhc_x = _data["ma_dvhc_x"];
        }
    }

    static fromJS(data: any): DTOMaTinhHuyenXa {
        data = typeof data === 'object' ? data : {};
        let result = new DTOMaTinhHuyenXa();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        data["ma_dvhc_h"] = this.ma_dvhc_h;
        data["ma_dvhc_x"] = this.ma_dvhc_x;
        return data; 
    }

    clone(): DTOMaTinhHuyenXa {
        const json = this.toJSON();
        let result = new DTOMaTinhHuyenXa();
        result.init(json);
        return result;
    }
}

export interface IDTOMaTinhHuyenXa {
    ma_dvhc_t: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_x: string | undefined;
}

export class DTOSearchPAKN implements IDTOSearchPAKN {
    id: number;
    title: string | undefined;
    content: string | undefined;
    paTime: string | undefined;
    diaChi: string | undefined;
    state: number;
    idUserSend: number;
    idDoiTuong: number;
    tenDoiTuong: string | undefined;
    idToChucQLDoiTuong: number;
    tenToChucQLDoiTuong: string | undefined;
    ma_dvhc_t: string | undefined;
    ten_dvhc_t: string | undefined;
    ma_dvhc_h: string | undefined;
    ten_dvhc_h: string | undefined;
    ma_dvhc_x: string | undefined;
    ten_dvhc_x: string | undefined;
    idLoaiSuKien: number;
    tenLoaiSuKien: string | undefined;
    geom: string | undefined;
    stateName: string | undefined;

    constructor(data?: IDTOSearchPAKN) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.paTime = _data["paTime"];
            this.diaChi = _data["diaChi"];
            this.state = _data["state"];
            this.idUserSend = _data["idUserSend"];
            this.idDoiTuong = _data["idDoiTuong"];
            this.tenDoiTuong = _data["tenDoiTuong"];
            this.idToChucQLDoiTuong = _data["idToChucQLDoiTuong"];
            this.tenToChucQLDoiTuong = _data["tenToChucQLDoiTuong"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
            this.ten_dvhc_t = _data["ten_dvhc_t"];
            this.ma_dvhc_h = _data["ma_dvhc_h"];
            this.ten_dvhc_h = _data["ten_dvhc_h"];
            this.ma_dvhc_x = _data["ma_dvhc_x"];
            this.ten_dvhc_x = _data["ten_dvhc_x"];
            this.idLoaiSuKien = _data["idLoaiSuKien"];
            this.tenLoaiSuKien = _data["tenLoaiSuKien"];
            this.geom = _data["geom"];
            this.stateName = _data["stateName"];
        }
    }

    static fromJS(data: any): DTOSearchPAKN {
        data = typeof data === 'object' ? data : {};
        let result = new DTOSearchPAKN();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["paTime"] = this.paTime;
        data["diaChi"] = this.diaChi;
        data["state"] = this.state;
        data["idUserSend"] = this.idUserSend;
        data["idDoiTuong"] = this.idDoiTuong;
        data["tenDoiTuong"] = this.tenDoiTuong;
        data["idToChucQLDoiTuong"] = this.idToChucQLDoiTuong;
        data["tenToChucQLDoiTuong"] = this.tenToChucQLDoiTuong;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        data["ten_dvhc_t"] = this.ten_dvhc_t;
        data["ma_dvhc_h"] = this.ma_dvhc_h;
        data["ten_dvhc_h"] = this.ten_dvhc_h;
        data["ma_dvhc_x"] = this.ma_dvhc_x;
        data["ten_dvhc_x"] = this.ten_dvhc_x;
        data["idLoaiSuKien"] = this.idLoaiSuKien;
        data["tenLoaiSuKien"] = this.tenLoaiSuKien;
        data["geom"] = this.geom;
        data["stateName"] = this.stateName;
        return data; 
    }

    clone(): DTOSearchPAKN {
        const json = this.toJSON();
        let result = new DTOSearchPAKN();
        result.init(json);
        return result;
    }
}

export interface IDTOSearchPAKN {
    id: number;
    title: string | undefined;
    content: string | undefined;
    paTime: string | undefined;
    diaChi: string | undefined;
    state: number;
    idUserSend: number;
    idDoiTuong: number;
    tenDoiTuong: string | undefined;
    idToChucQLDoiTuong: number;
    tenToChucQLDoiTuong: string | undefined;
    ma_dvhc_t: string | undefined;
    ten_dvhc_t: string | undefined;
    ma_dvhc_h: string | undefined;
    ten_dvhc_h: string | undefined;
    ma_dvhc_x: string | undefined;
    ten_dvhc_x: string | undefined;
    idLoaiSuKien: number;
    tenLoaiSuKien: string | undefined;
    geom: string | undefined;
    stateName: string | undefined;
}

export class DTOTKPAKN implements IDTOTKPAKN {
    moiTao: number;
    moiGui: number;
    pheDuyet: number;
    tuChoi: number;
    yeuCauCapNhat: number;
    congKhai: number;

    constructor(data?: IDTOTKPAKN) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.moiTao = _data["moiTao"];
            this.moiGui = _data["moiGui"];
            this.pheDuyet = _data["pheDuyet"];
            this.tuChoi = _data["tuChoi"];
            this.yeuCauCapNhat = _data["yeuCauCapNhat"];
            this.congKhai = _data["congKhai"];
        }
    }

    static fromJS(data: any): DTOTKPAKN {
        data = typeof data === 'object' ? data : {};
        let result = new DTOTKPAKN();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moiTao"] = this.moiTao;
        data["moiGui"] = this.moiGui;
        data["pheDuyet"] = this.pheDuyet;
        data["tuChoi"] = this.tuChoi;
        data["yeuCauCapNhat"] = this.yeuCauCapNhat;
        data["congKhai"] = this.congKhai;
        return data; 
    }

    clone(): DTOTKPAKN {
        const json = this.toJSON();
        let result = new DTOTKPAKN();
        result.init(json);
        return result;
    }
}

export interface IDTOTKPAKN {
    moiTao: number;
    moiGui: number;
    pheDuyet: number;
    tuChoi: number;
    yeuCauCapNhat: number;
    congKhai: number;
}

export class DTOUserDoiTuong implements IDTOUserDoiTuong {
    id: number;
    name: string | undefined;
    parentId: number;

    constructor(data?: IDTOUserDoiTuong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): DTOUserDoiTuong {
        data = typeof data === 'object' ? data : {};
        let result = new DTOUserDoiTuong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        return data; 
    }

    clone(): DTOUserDoiTuong {
        const json = this.toJSON();
        let result = new DTOUserDoiTuong();
        result.init(json);
        return result;
    }
}

export interface IDTOUserDoiTuong {
    id: number;
    name: string | undefined;
    parentId: number;
}

export class DTOXemBCDVHC implements IDTOXemBCDVHC {
    dvhC_MaTinh: string | undefined;
    dvhC_MaHuyen: string | undefined;

    constructor(data?: IDTOXemBCDVHC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dvhC_MaTinh = _data["dvhC_MaTinh"];
            this.dvhC_MaHuyen = _data["dvhC_MaHuyen"];
        }
    }

    static fromJS(data: any): DTOXemBCDVHC {
        data = typeof data === 'object' ? data : {};
        let result = new DTOXemBCDVHC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dvhC_MaTinh"] = this.dvhC_MaTinh;
        data["dvhC_MaHuyen"] = this.dvhC_MaHuyen;
        return data; 
    }

    clone(): DTOXemBCDVHC {
        const json = this.toJSON();
        let result = new DTOXemBCDVHC();
        result.init(json);
        return result;
    }
}

export interface IDTOXemBCDVHC {
    dvhC_MaTinh: string | undefined;
    dvhC_MaHuyen: string | undefined;
}

export class DVHC_UserViewDto implements IDVHC_UserViewDto {
    id: number;
    userName: string | undefined;
    tenTinh: string | undefined;
    tenHuyen: string | undefined;
    tenXa: string | undefined;

    constructor(data?: IDVHC_UserViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.tenTinh = _data["tenTinh"];
            this.tenHuyen = _data["tenHuyen"];
            this.tenXa = _data["tenXa"];
        }
    }

    static fromJS(data: any): DVHC_UserViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new DVHC_UserViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["tenTinh"] = this.tenTinh;
        data["tenHuyen"] = this.tenHuyen;
        data["tenXa"] = this.tenXa;
        return data; 
    }

    clone(): DVHC_UserViewDto {
        const json = this.toJSON();
        let result = new DVHC_UserViewDto();
        result.init(json);
        return result;
    }
}

export interface IDVHC_UserViewDto {
    id: number;
    userName: string | undefined;
    tenTinh: string | undefined;
    tenHuyen: string | undefined;
    tenXa: string | undefined;
}

export class DiaBan implements IDiaBan {
    id: number;
    tenDiaBan: string | undefined;
    maTinh: string | undefined;
    maHuyen: string | undefined;
    maXa: string | undefined;

    constructor(data?: IDiaBan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenDiaBan = _data["tenDiaBan"];
            this.maTinh = _data["maTinh"];
            this.maHuyen = _data["maHuyen"];
            this.maXa = _data["maXa"];
        }
    }

    static fromJS(data: any): DiaBan {
        data = typeof data === 'object' ? data : {};
        let result = new DiaBan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenDiaBan"] = this.tenDiaBan;
        data["maTinh"] = this.maTinh;
        data["maHuyen"] = this.maHuyen;
        data["maXa"] = this.maXa;
        return data; 
    }

    clone(): DiaBan {
        const json = this.toJSON();
        let result = new DiaBan();
        result.init(json);
        return result;
    }
}

export interface IDiaBan {
    id: number;
    tenDiaBan: string | undefined;
    maTinh: string | undefined;
    maHuyen: string | undefined;
    maXa: string | undefined;
}

export class DiaBanPagedResultDto implements IDiaBanPagedResultDto {
    items: DiaBan[] | undefined;
    totalCount: number;

    constructor(data?: IDiaBanPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DiaBan.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DiaBanPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiaBanPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DiaBanPagedResultDto {
        const json = this.toJSON();
        let result = new DiaBanPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDiaBanPagedResultDto {
    items: DiaBan[] | undefined;
    totalCount: number;
}

export enum Dimension {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    __3 = -3,
    __2 = -2,
    __1 = -1,
}

export class DoiTuongDto implements IDoiTuongDto {
    id: number;
    code: string | undefined;
    name: string;
    address: string | undefined;
    nguoiDaiDien: string | undefined;
    organizationUnitId: number | undefined;
    ngayBatDau: moment.Moment | undefined;
    ngayKetThuc: moment.Moment | undefined;
    user_Id: string[] | undefined;
    nhiemVuId: number | undefined;
    loaiDoiTuongId: number | undefined;
    tenNguoiDaiDien: string | undefined;

    constructor(data?: IDoiTuongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.nguoiDaiDien = _data["nguoiDaiDien"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.ngayBatDau = _data["ngayBatDau"] ? moment(_data["ngayBatDau"].toString()) : <any>undefined;
            this.ngayKetThuc = _data["ngayKetThuc"] ? moment(_data["ngayKetThuc"].toString()) : <any>undefined;
            if (Array.isArray(_data["user_Id"])) {
                this.user_Id = [] as any;
                for (let item of _data["user_Id"])
                    this.user_Id.push(item);
            }
            this.nhiemVuId = _data["nhiemVuId"];
            this.loaiDoiTuongId = _data["loaiDoiTuongId"];
            this.tenNguoiDaiDien = _data["tenNguoiDaiDien"];
        }
    }

    static fromJS(data: any): DoiTuongDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoiTuongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["address"] = this.address;
        data["nguoiDaiDien"] = this.nguoiDaiDien;
        data["organizationUnitId"] = this.organizationUnitId;
        data["ngayBatDau"] = this.ngayBatDau ? this.ngayBatDau.toISOString() : <any>undefined;
        data["ngayKetThuc"] = this.ngayKetThuc ? this.ngayKetThuc.toISOString() : <any>undefined;
        if (Array.isArray(this.user_Id)) {
            data["user_Id"] = [];
            for (let item of this.user_Id)
                data["user_Id"].push(item);
        }
        data["nhiemVuId"] = this.nhiemVuId;
        data["loaiDoiTuongId"] = this.loaiDoiTuongId;
        data["tenNguoiDaiDien"] = this.tenNguoiDaiDien;
        return data; 
    }

    clone(): DoiTuongDto {
        const json = this.toJSON();
        let result = new DoiTuongDto();
        result.init(json);
        return result;
    }
}

export interface IDoiTuongDto {
    id: number;
    code: string | undefined;
    name: string;
    address: string | undefined;
    nguoiDaiDien: string | undefined;
    organizationUnitId: number | undefined;
    ngayBatDau: moment.Moment | undefined;
    ngayKetThuc: moment.Moment | undefined;
    user_Id: string[] | undefined;
    nhiemVuId: number | undefined;
    loaiDoiTuongId: number | undefined;
    tenNguoiDaiDien: string | undefined;
}

export class DoiTuongUserBCDto implements IDoiTuongUserBCDto {
    id: number;
    userId: number;
    tenDoiTuong: string | undefined;

    constructor(data?: IDoiTuongUserBCDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.tenDoiTuong = _data["tenDoiTuong"];
        }
    }

    static fromJS(data: any): DoiTuongUserBCDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoiTuongUserBCDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["tenDoiTuong"] = this.tenDoiTuong;
        return data; 
    }

    clone(): DoiTuongUserBCDto {
        const json = this.toJSON();
        let result = new DoiTuongUserBCDto();
        result.init(json);
        return result;
    }
}

export interface IDoiTuongUserBCDto {
    id: number;
    userId: number;
    tenDoiTuong: string | undefined;
}

export class DoiTuongUserEmpty implements IDoiTuongUserEmpty {
    id: number;
    name: string | undefined;
    ngayNhacViec: moment.Moment | undefined;
    isActive: boolean;
    nhacTruoc: number;
    noiDung: string | undefined;
    isChecked: boolean;
    type: number;

    constructor(data?: IDoiTuongUserEmpty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.ngayNhacViec = _data["ngayNhacViec"] ? moment(_data["ngayNhacViec"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.nhacTruoc = _data["nhacTruoc"];
            this.noiDung = _data["noiDung"];
            this.isChecked = _data["isChecked"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): DoiTuongUserEmpty {
        data = typeof data === 'object' ? data : {};
        let result = new DoiTuongUserEmpty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["ngayNhacViec"] = this.ngayNhacViec ? this.ngayNhacViec.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["nhacTruoc"] = this.nhacTruoc;
        data["noiDung"] = this.noiDung;
        data["isChecked"] = this.isChecked;
        data["type"] = this.type;
        return data; 
    }

    clone(): DoiTuongUserEmpty {
        const json = this.toJSON();
        let result = new DoiTuongUserEmpty();
        result.init(json);
        return result;
    }
}

export interface IDoiTuongUserEmpty {
    id: number;
    name: string | undefined;
    ngayNhacViec: moment.Moment | undefined;
    isActive: boolean;
    nhacTruoc: number;
    noiDung: string | undefined;
    isChecked: boolean;
    type: number;
}

export class DoiTuongViewDto implements IDoiTuongViewDto {
    id: number;
    code: string;
    name: string | undefined;
    address: string | undefined;
    nguoiDaiDien: string | undefined;
    organizationUnitId: number | undefined;
    nhiemVuId: number | undefined;
    loaiDoiTuongId: number | undefined;
    ngayBatDau: moment.Moment | undefined;
    ngayKetThuc: moment.Moment | undefined;
    tenNguoiDaiDien: string | undefined;
    tenToChuc: string | undefined;
    user_Id: string[] | undefined;

    constructor(data?: IDoiTuongViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.nguoiDaiDien = _data["nguoiDaiDien"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.nhiemVuId = _data["nhiemVuId"];
            this.loaiDoiTuongId = _data["loaiDoiTuongId"];
            this.ngayBatDau = _data["ngayBatDau"] ? moment(_data["ngayBatDau"].toString()) : <any>undefined;
            this.ngayKetThuc = _data["ngayKetThuc"] ? moment(_data["ngayKetThuc"].toString()) : <any>undefined;
            this.tenNguoiDaiDien = _data["tenNguoiDaiDien"];
            this.tenToChuc = _data["tenToChuc"];
            if (Array.isArray(_data["user_Id"])) {
                this.user_Id = [] as any;
                for (let item of _data["user_Id"])
                    this.user_Id.push(item);
            }
        }
    }

    static fromJS(data: any): DoiTuongViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoiTuongViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["address"] = this.address;
        data["nguoiDaiDien"] = this.nguoiDaiDien;
        data["organizationUnitId"] = this.organizationUnitId;
        data["nhiemVuId"] = this.nhiemVuId;
        data["loaiDoiTuongId"] = this.loaiDoiTuongId;
        data["ngayBatDau"] = this.ngayBatDau ? this.ngayBatDau.toISOString() : <any>undefined;
        data["ngayKetThuc"] = this.ngayKetThuc ? this.ngayKetThuc.toISOString() : <any>undefined;
        data["tenNguoiDaiDien"] = this.tenNguoiDaiDien;
        data["tenToChuc"] = this.tenToChuc;
        if (Array.isArray(this.user_Id)) {
            data["user_Id"] = [];
            for (let item of this.user_Id)
                data["user_Id"].push(item);
        }
        return data; 
    }

    clone(): DoiTuongViewDto {
        const json = this.toJSON();
        let result = new DoiTuongViewDto();
        result.init(json);
        return result;
    }
}

export interface IDoiTuongViewDto {
    id: number;
    code: string;
    name: string | undefined;
    address: string | undefined;
    nguoiDaiDien: string | undefined;
    organizationUnitId: number | undefined;
    nhiemVuId: number | undefined;
    loaiDoiTuongId: number | undefined;
    ngayBatDau: moment.Moment | undefined;
    ngayKetThuc: moment.Moment | undefined;
    tenNguoiDaiDien: string | undefined;
    tenToChuc: string | undefined;
    user_Id: string[] | undefined;
}

export class DoiTuongViewDtoPagedResultDto implements IDoiTuongViewDtoPagedResultDto {
    items: DoiTuongViewDto[] | undefined;
    totalCount: number;

    constructor(data?: IDoiTuongViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DoiTuongViewDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DoiTuongViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DoiTuongViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DoiTuongViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DoiTuongViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDoiTuongViewDtoPagedResultDto {
    items: DoiTuongViewDto[] | undefined;
    totalCount: number;
}

export class DuyetDoiTuongUserEmpty implements IDuyetDoiTuongUserEmpty {
    id: number;
    name: string | undefined;
    ngayNhacViec: moment.Moment | undefined;
    isActive: boolean;
    nhacTruoc: number;
    noiDung: string | undefined;
    isChecked: boolean;
    isDisabled: boolean;
    type: number;

    constructor(data?: IDuyetDoiTuongUserEmpty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.ngayNhacViec = _data["ngayNhacViec"] ? moment(_data["ngayNhacViec"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.nhacTruoc = _data["nhacTruoc"];
            this.noiDung = _data["noiDung"];
            this.isChecked = _data["isChecked"];
            this.isDisabled = _data["isDisabled"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): DuyetDoiTuongUserEmpty {
        data = typeof data === 'object' ? data : {};
        let result = new DuyetDoiTuongUserEmpty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["ngayNhacViec"] = this.ngayNhacViec ? this.ngayNhacViec.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["nhacTruoc"] = this.nhacTruoc;
        data["noiDung"] = this.noiDung;
        data["isChecked"] = this.isChecked;
        data["isDisabled"] = this.isDisabled;
        data["type"] = this.type;
        return data; 
    }

    clone(): DuyetDoiTuongUserEmpty {
        const json = this.toJSON();
        let result = new DuyetDoiTuongUserEmpty();
        result.init(json);
        return result;
    }
}

export interface IDuyetDoiTuongUserEmpty {
    id: number;
    name: string | undefined;
    ngayNhacViec: moment.Moment | undefined;
    isActive: boolean;
    nhacTruoc: number;
    noiDung: string | undefined;
    isChecked: boolean;
    isDisabled: boolean;
    type: number;
}

export class DuyetUserDoiTuong implements IDuyetUserDoiTuong {
    id: number;
    doiTuongId: number;
    userId: number;
    isActive: boolean;

    constructor(data?: IDuyetUserDoiTuong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.doiTuongId = _data["doiTuongId"];
            this.userId = _data["userId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): DuyetUserDoiTuong {
        data = typeof data === 'object' ? data : {};
        let result = new DuyetUserDoiTuong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["doiTuongId"] = this.doiTuongId;
        data["userId"] = this.userId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): DuyetUserDoiTuong {
        const json = this.toJSON();
        let result = new DuyetUserDoiTuong();
        result.init(json);
        return result;
    }
}

export interface IDuyetUserDoiTuong {
    id: number;
    doiTuongId: number;
    userId: number;
    isActive: boolean;
}

export class DuyetUserDoiTuongDto implements IDuyetUserDoiTuongDto {
    id: number;
    userId: number;
    objDoiTuong: ObjDoiTuongDuyet[] | undefined;

    constructor(data?: IDuyetUserDoiTuongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["objDoiTuong"])) {
                this.objDoiTuong = [] as any;
                for (let item of _data["objDoiTuong"])
                    this.objDoiTuong.push(ObjDoiTuongDuyet.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DuyetUserDoiTuongDto {
        data = typeof data === 'object' ? data : {};
        let result = new DuyetUserDoiTuongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        if (Array.isArray(this.objDoiTuong)) {
            data["objDoiTuong"] = [];
            for (let item of this.objDoiTuong)
                data["objDoiTuong"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DuyetUserDoiTuongDto {
        const json = this.toJSON();
        let result = new DuyetUserDoiTuongDto();
        result.init(json);
        return result;
    }
}

export interface IDuyetUserDoiTuongDto {
    id: number;
    userId: number;
    objDoiTuong: ObjDoiTuongDuyet[] | undefined;
}

export class DuyetUserDoiTuongViewDto implements IDuyetUserDoiTuongViewDto {
    id: number;
    userName: string | undefined;
    fullName: string | undefined;
    phoneNumber: string | undefined;
    tenToChuc: string | undefined;
    organizationUnitId: number | undefined;
    doiTuong: string[] | undefined;

    constructor(data?: IDuyetUserDoiTuongViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.phoneNumber = _data["phoneNumber"];
            this.tenToChuc = _data["tenToChuc"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["doiTuong"])) {
                this.doiTuong = [] as any;
                for (let item of _data["doiTuong"])
                    this.doiTuong.push(item);
            }
        }
    }

    static fromJS(data: any): DuyetUserDoiTuongViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new DuyetUserDoiTuongViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["phoneNumber"] = this.phoneNumber;
        data["tenToChuc"] = this.tenToChuc;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.doiTuong)) {
            data["doiTuong"] = [];
            for (let item of this.doiTuong)
                data["doiTuong"].push(item);
        }
        return data; 
    }

    clone(): DuyetUserDoiTuongViewDto {
        const json = this.toJSON();
        let result = new DuyetUserDoiTuongViewDto();
        result.init(json);
        return result;
    }
}

export interface IDuyetUserDoiTuongViewDto {
    id: number;
    userName: string | undefined;
    fullName: string | undefined;
    phoneNumber: string | undefined;
    tenToChuc: string | undefined;
    organizationUnitId: number | undefined;
    doiTuong: string[] | undefined;
}

export enum EMediaType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum ENhacViecState {
    _0 = 0,
    _1 = 1,
}

export enum EnumPaknState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum EnumPaknType {
    _0 = 0,
    _1 = 1,
}

export class Envelope implements IEnvelope {
    readonly isNull: boolean;
    readonly width: number;
    readonly height: number;
    readonly minX: number;
    readonly maxX: number;
    readonly minY: number;
    readonly maxY: number;
    readonly area: number;
    readonly minExtent: number;
    readonly maxExtent: number;
    centre: Coordinate;

    constructor(data?: IEnvelope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isNull = _data["isNull"];
            (<any>this).width = _data["width"];
            (<any>this).height = _data["height"];
            (<any>this).minX = _data["minX"];
            (<any>this).maxX = _data["maxX"];
            (<any>this).minY = _data["minY"];
            (<any>this).maxY = _data["maxY"];
            (<any>this).area = _data["area"];
            (<any>this).minExtent = _data["minExtent"];
            (<any>this).maxExtent = _data["maxExtent"];
            this.centre = _data["centre"] ? Coordinate.fromJS(_data["centre"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Envelope {
        data = typeof data === 'object' ? data : {};
        let result = new Envelope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNull"] = this.isNull;
        data["width"] = this.width;
        data["height"] = this.height;
        data["minX"] = this.minX;
        data["maxX"] = this.maxX;
        data["minY"] = this.minY;
        data["maxY"] = this.maxY;
        data["area"] = this.area;
        data["minExtent"] = this.minExtent;
        data["maxExtent"] = this.maxExtent;
        data["centre"] = this.centre ? this.centre.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Envelope {
        const json = this.toJSON();
        let result = new Envelope();
        result.init(json);
        return result;
    }
}

export interface IEnvelope {
    isNull: boolean;
    width: number;
    height: number;
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
    area: number;
    minExtent: number;
    maxExtent: number;
    centre: Coordinate;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class Geometry implements IGeometry {
    factory: GeometryFactory;
    userData: any | undefined;
    srid: number;
    readonly geometryType: string | undefined;
    ogcGeometryType: OgcGeometryType;
    precisionModel: PrecisionModel;
    coordinate: Coordinate;
    readonly coordinates: Coordinate[] | undefined;
    readonly numPoints: number;
    readonly numGeometries: number;
    readonly isSimple: boolean;
    readonly isValid: boolean;
    readonly isEmpty: boolean;
    readonly area: number;
    readonly length: number;
    centroid: Point;
    interiorPoint: Point;
    pointOnSurface: Point;
    dimension: Dimension;
    boundary: Geometry;
    boundaryDimension: Dimension;
    envelope: Geometry;
    envelopeInternal: Envelope;
    readonly isRectangle: boolean;

    constructor(data?: IGeometry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.factory = _data["factory"] ? GeometryFactory.fromJS(_data["factory"]) : <any>undefined;
            this.userData = _data["userData"];
            this.srid = _data["srid"];
            (<any>this).geometryType = _data["geometryType"];
            this.ogcGeometryType = _data["ogcGeometryType"];
            this.precisionModel = _data["precisionModel"] ? PrecisionModel.fromJS(_data["precisionModel"]) : <any>undefined;
            this.coordinate = _data["coordinate"] ? Coordinate.fromJS(_data["coordinate"]) : <any>undefined;
            if (Array.isArray(_data["coordinates"])) {
                (<any>this).coordinates = [] as any;
                for (let item of _data["coordinates"])
                    (<any>this).coordinates.push(Coordinate.fromJS(item));
            }
            (<any>this).numPoints = _data["numPoints"];
            (<any>this).numGeometries = _data["numGeometries"];
            (<any>this).isSimple = _data["isSimple"];
            (<any>this).isValid = _data["isValid"];
            (<any>this).isEmpty = _data["isEmpty"];
            (<any>this).area = _data["area"];
            (<any>this).length = _data["length"];
            this.centroid = _data["centroid"] ? Point.fromJS(_data["centroid"]) : <any>undefined;
            this.interiorPoint = _data["interiorPoint"] ? Point.fromJS(_data["interiorPoint"]) : <any>undefined;
            this.pointOnSurface = _data["pointOnSurface"] ? Point.fromJS(_data["pointOnSurface"]) : <any>undefined;
            this.dimension = _data["dimension"];
            this.boundary = _data["boundary"] ? Geometry.fromJS(_data["boundary"]) : <any>undefined;
            this.boundaryDimension = _data["boundaryDimension"];
            this.envelope = _data["envelope"] ? Geometry.fromJS(_data["envelope"]) : <any>undefined;
            this.envelopeInternal = _data["envelopeInternal"] ? Envelope.fromJS(_data["envelopeInternal"]) : <any>undefined;
            (<any>this).isRectangle = _data["isRectangle"];
        }
    }

    static fromJS(data: any): Geometry {
        data = typeof data === 'object' ? data : {};
        let result = new Geometry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["factory"] = this.factory ? this.factory.toJSON() : <any>undefined;
        data["userData"] = this.userData;
        data["srid"] = this.srid;
        data["geometryType"] = this.geometryType;
        data["ogcGeometryType"] = this.ogcGeometryType;
        data["precisionModel"] = this.precisionModel ? this.precisionModel.toJSON() : <any>undefined;
        data["coordinate"] = this.coordinate ? this.coordinate.toJSON() : <any>undefined;
        if (Array.isArray(this.coordinates)) {
            data["coordinates"] = [];
            for (let item of this.coordinates)
                data["coordinates"].push(item.toJSON());
        }
        data["numPoints"] = this.numPoints;
        data["numGeometries"] = this.numGeometries;
        data["isSimple"] = this.isSimple;
        data["isValid"] = this.isValid;
        data["isEmpty"] = this.isEmpty;
        data["area"] = this.area;
        data["length"] = this.length;
        data["centroid"] = this.centroid ? this.centroid.toJSON() : <any>undefined;
        data["interiorPoint"] = this.interiorPoint ? this.interiorPoint.toJSON() : <any>undefined;
        data["pointOnSurface"] = this.pointOnSurface ? this.pointOnSurface.toJSON() : <any>undefined;
        data["dimension"] = this.dimension;
        data["boundary"] = this.boundary ? this.boundary.toJSON() : <any>undefined;
        data["boundaryDimension"] = this.boundaryDimension;
        data["envelope"] = this.envelope ? this.envelope.toJSON() : <any>undefined;
        data["envelopeInternal"] = this.envelopeInternal ? this.envelopeInternal.toJSON() : <any>undefined;
        data["isRectangle"] = this.isRectangle;
        return data; 
    }

    clone(): Geometry {
        const json = this.toJSON();
        let result = new Geometry();
        result.init(json);
        return result;
    }
}

export interface IGeometry {
    factory: GeometryFactory;
    userData: any | undefined;
    srid: number;
    geometryType: string | undefined;
    ogcGeometryType: OgcGeometryType;
    precisionModel: PrecisionModel;
    coordinate: Coordinate;
    coordinates: Coordinate[] | undefined;
    numPoints: number;
    numGeometries: number;
    isSimple: boolean;
    isValid: boolean;
    isEmpty: boolean;
    area: number;
    length: number;
    centroid: Point;
    interiorPoint: Point;
    pointOnSurface: Point;
    dimension: Dimension;
    boundary: Geometry;
    boundaryDimension: Dimension;
    envelope: Geometry;
    envelopeInternal: Envelope;
    isRectangle: boolean;
}

export class GeometryFactory implements IGeometryFactory {
    precisionModel: PrecisionModel;
    coordinateSequenceFactory: CoordinateSequenceFactory;
    readonly srid: number;

    constructor(data?: IGeometryFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.precisionModel = _data["precisionModel"] ? PrecisionModel.fromJS(_data["precisionModel"]) : <any>undefined;
            this.coordinateSequenceFactory = _data["coordinateSequenceFactory"] ? CoordinateSequenceFactory.fromJS(_data["coordinateSequenceFactory"]) : <any>undefined;
            (<any>this).srid = _data["srid"];
        }
    }

    static fromJS(data: any): GeometryFactory {
        data = typeof data === 'object' ? data : {};
        let result = new GeometryFactory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["precisionModel"] = this.precisionModel ? this.precisionModel.toJSON() : <any>undefined;
        data["coordinateSequenceFactory"] = this.coordinateSequenceFactory ? this.coordinateSequenceFactory.toJSON() : <any>undefined;
        data["srid"] = this.srid;
        return data; 
    }

    clone(): GeometryFactory {
        const json = this.toJSON();
        let result = new GeometryFactory();
        result.init(json);
        return result;
    }
}

export interface IGeometryFactory {
    precisionModel: PrecisionModel;
    coordinateSequenceFactory: CoordinateSequenceFactory;
    srid: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetUserByIdOutput implements IGetUserByIdOutput {
    username: string | undefined;

    constructor(data?: IGetUserByIdOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): GetUserByIdOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserByIdOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        return data; 
    }

    clone(): GetUserByIdOutput {
        const json = this.toJSON();
        let result = new GetUserByIdOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserByIdOutput {
    username: string | undefined;
}

export class HistoryAddNguoiTaoDto implements IHistoryAddNguoiTaoDto {
    id: number;
    paknId: number;
    noiDung: string | undefined;
    trangThai: number | undefined;
    tenTrangThai: string | undefined;
    ngayTao: moment.Moment | undefined;
    nguoiTao: string | undefined;

    constructor(data?: IHistoryAddNguoiTaoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paknId = _data["paknId"];
            this.noiDung = _data["noiDung"];
            this.trangThai = _data["trangThai"];
            this.tenTrangThai = _data["tenTrangThai"];
            this.ngayTao = _data["ngayTao"] ? moment(_data["ngayTao"].toString()) : <any>undefined;
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any): HistoryAddNguoiTaoDto {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryAddNguoiTaoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paknId"] = this.paknId;
        data["noiDung"] = this.noiDung;
        data["trangThai"] = this.trangThai;
        data["tenTrangThai"] = this.tenTrangThai;
        data["ngayTao"] = this.ngayTao ? this.ngayTao.toISOString() : <any>undefined;
        data["nguoiTao"] = this.nguoiTao;
        return data; 
    }

    clone(): HistoryAddNguoiTaoDto {
        const json = this.toJSON();
        let result = new HistoryAddNguoiTaoDto();
        result.init(json);
        return result;
    }
}

export interface IHistoryAddNguoiTaoDto {
    id: number;
    paknId: number;
    noiDung: string | undefined;
    trangThai: number | undefined;
    tenTrangThai: string | undefined;
    ngayTao: moment.Moment | undefined;
    nguoiTao: string | undefined;
}

export class HistorysDto implements IHistorysDto {
    id: number;
    paknId: number;
    noiDung: string | undefined;
    trangThai: number | undefined;
    tenTrangThai: string | undefined;
    ngayTao: moment.Moment | undefined;
    nguoiTao: number | undefined;

    constructor(data?: IHistorysDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paknId = _data["paknId"];
            this.noiDung = _data["noiDung"];
            this.trangThai = _data["trangThai"];
            this.tenTrangThai = _data["tenTrangThai"];
            this.ngayTao = _data["ngayTao"] ? moment(_data["ngayTao"].toString()) : <any>undefined;
            this.nguoiTao = _data["nguoiTao"];
        }
    }

    static fromJS(data: any): HistorysDto {
        data = typeof data === 'object' ? data : {};
        let result = new HistorysDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paknId"] = this.paknId;
        data["noiDung"] = this.noiDung;
        data["trangThai"] = this.trangThai;
        data["tenTrangThai"] = this.tenTrangThai;
        data["ngayTao"] = this.ngayTao ? this.ngayTao.toISOString() : <any>undefined;
        data["nguoiTao"] = this.nguoiTao;
        return data; 
    }

    clone(): HistorysDto {
        const json = this.toJSON();
        let result = new HistorysDto();
        result.init(json);
        return result;
    }
}

export interface IHistorysDto {
    id: number;
    paknId: number;
    noiDung: string | undefined;
    trangThai: number | undefined;
    tenTrangThai: string | undefined;
    ngayTao: moment.Moment | undefined;
    nguoiTao: number | undefined;
}

export class HomeViewDto implements IHomeViewDto {
    id: number;
    tieuDe: string | undefined;
    noiDung: string | undefined;
    userIds: number[] | undefined;
    tenNguoiDung: string[] | undefined;
    ngayTao: moment.Moment;

    constructor(data?: IHomeViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tieuDe = _data["tieuDe"];
            this.noiDung = _data["noiDung"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds.push(item);
            }
            if (Array.isArray(_data["tenNguoiDung"])) {
                this.tenNguoiDung = [] as any;
                for (let item of _data["tenNguoiDung"])
                    this.tenNguoiDung.push(item);
            }
            this.ngayTao = _data["ngayTao"] ? moment(_data["ngayTao"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HomeViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new HomeViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tieuDe"] = this.tieuDe;
        data["noiDung"] = this.noiDung;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        if (Array.isArray(this.tenNguoiDung)) {
            data["tenNguoiDung"] = [];
            for (let item of this.tenNguoiDung)
                data["tenNguoiDung"].push(item);
        }
        data["ngayTao"] = this.ngayTao ? this.ngayTao.toISOString() : <any>undefined;
        return data; 
    }

    clone(): HomeViewDto {
        const json = this.toJSON();
        let result = new HomeViewDto();
        result.init(json);
        return result;
    }
}

export interface IHomeViewDto {
    id: number;
    tieuDe: string | undefined;
    noiDung: string | undefined;
    userIds: number[] | undefined;
    tenNguoiDung: string[] | undefined;
    ngayTao: moment.Moment;
}

export class HomeViewDtoPagedResultDto implements IHomeViewDtoPagedResultDto {
    items: HomeViewDto[] | undefined;
    totalCount: number;

    constructor(data?: IHomeViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HomeViewDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): HomeViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HomeViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): HomeViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HomeViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHomeViewDtoPagedResultDto {
    items: HomeViewDto[] | undefined;
    totalCount: number;
}

export class Huyen implements IHuyen {
    id: number;
    wkb_geometry: Geometry[] | undefined;
    ma_dvhc_h: string | undefined;
    ten_dvhc_h: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    ghichu: string | undefined;
    ma_dvhc_t: string | undefined;

    constructor(data?: IHuyen) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["wkb_geometry"])) {
                this.wkb_geometry = [] as any;
                for (let item of _data["wkb_geometry"])
                    this.wkb_geometry.push(Geometry.fromJS(item));
            }
            this.ma_dvhc_h = _data["ma_dvhc_h"];
            this.ten_dvhc_h = _data["ten_dvhc_h"];
            this.dientich = _data["dientich"];
            this.dan_so = _data["dan_so"];
            this.tentinh = _data["tentinh"];
            this.ghichu = _data["ghichu"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
        }
    }

    static fromJS(data: any): Huyen {
        data = typeof data === 'object' ? data : {};
        let result = new Huyen();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.wkb_geometry)) {
            data["wkb_geometry"] = [];
            for (let item of this.wkb_geometry)
                data["wkb_geometry"].push(item.toJSON());
        }
        data["ma_dvhc_h"] = this.ma_dvhc_h;
        data["ten_dvhc_h"] = this.ten_dvhc_h;
        data["dientich"] = this.dientich;
        data["dan_so"] = this.dan_so;
        data["tentinh"] = this.tentinh;
        data["ghichu"] = this.ghichu;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        return data; 
    }

    clone(): Huyen {
        const json = this.toJSON();
        let result = new Huyen();
        result.init(json);
        return result;
    }
}

export interface IHuyen {
    id: number;
    wkb_geometry: Geometry[] | undefined;
    ma_dvhc_h: string | undefined;
    ten_dvhc_h: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    ghichu: string | undefined;
    ma_dvhc_t: string | undefined;
}

export class HuyenDto implements IHuyenDto {
    id: number;
    wkb_geometry: string | undefined;
    ma_dvhc_h: string | undefined;
    ten_dvhc_h: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    ghichu: string | undefined;
    ma_dvhc_t: string | undefined;

    constructor(data?: IHuyenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.wkb_geometry = _data["wkb_geometry"];
            this.ma_dvhc_h = _data["ma_dvhc_h"];
            this.ten_dvhc_h = _data["ten_dvhc_h"];
            this.dientich = _data["dientich"];
            this.dan_so = _data["dan_so"];
            this.tentinh = _data["tentinh"];
            this.ghichu = _data["ghichu"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
        }
    }

    static fromJS(data: any): HuyenDto {
        data = typeof data === 'object' ? data : {};
        let result = new HuyenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["wkb_geometry"] = this.wkb_geometry;
        data["ma_dvhc_h"] = this.ma_dvhc_h;
        data["ten_dvhc_h"] = this.ten_dvhc_h;
        data["dientich"] = this.dientich;
        data["dan_so"] = this.dan_so;
        data["tentinh"] = this.tentinh;
        data["ghichu"] = this.ghichu;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        return data; 
    }

    clone(): HuyenDto {
        const json = this.toJSON();
        let result = new HuyenDto();
        result.init(json);
        return result;
    }
}

export interface IHuyenDto {
    id: number;
    wkb_geometry: string | undefined;
    ma_dvhc_h: string | undefined;
    ten_dvhc_h: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    ghichu: string | undefined;
    ma_dvhc_t: string | undefined;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class LoaiDoiTuong implements ILoaiDoiTuong {
    id: number;
    tenLoaiDoiTuong: string | undefined;

    constructor(data?: ILoaiDoiTuong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenLoaiDoiTuong = _data["tenLoaiDoiTuong"];
        }
    }

    static fromJS(data: any): LoaiDoiTuong {
        data = typeof data === 'object' ? data : {};
        let result = new LoaiDoiTuong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenLoaiDoiTuong"] = this.tenLoaiDoiTuong;
        return data; 
    }

    clone(): LoaiDoiTuong {
        const json = this.toJSON();
        let result = new LoaiDoiTuong();
        result.init(json);
        return result;
    }
}

export interface ILoaiDoiTuong {
    id: number;
    tenLoaiDoiTuong: string | undefined;
}

export class LoaiDoiTuongInputDto implements ILoaiDoiTuongInputDto {
    id: number;
    tenLoaiDoiTuong: string | undefined;

    constructor(data?: ILoaiDoiTuongInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenLoaiDoiTuong = _data["tenLoaiDoiTuong"];
        }
    }

    static fromJS(data: any): LoaiDoiTuongInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoaiDoiTuongInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenLoaiDoiTuong"] = this.tenLoaiDoiTuong;
        return data; 
    }

    clone(): LoaiDoiTuongInputDto {
        const json = this.toJSON();
        let result = new LoaiDoiTuongInputDto();
        result.init(json);
        return result;
    }
}

export interface ILoaiDoiTuongInputDto {
    id: number;
    tenLoaiDoiTuong: string | undefined;
}

export class LoaiDoiTuongPagedResultDto implements ILoaiDoiTuongPagedResultDto {
    items: LoaiDoiTuong[] | undefined;
    totalCount: number;

    constructor(data?: ILoaiDoiTuongPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LoaiDoiTuong.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LoaiDoiTuongPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoaiDoiTuongPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LoaiDoiTuongPagedResultDto {
        const json = this.toJSON();
        let result = new LoaiDoiTuongPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILoaiDoiTuongPagedResultDto {
    items: LoaiDoiTuong[] | undefined;
    totalCount: number;
}

export class MailRequest implements IMailRequest {
    userName: string | undefined;
    toEmail: string | undefined;

    constructor(data?: IMailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.toEmail = _data["toEmail"];
        }
    }

    static fromJS(data: any): MailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["toEmail"] = this.toEmail;
        return data; 
    }

    clone(): MailRequest {
        const json = this.toJSON();
        let result = new MailRequest();
        result.init(json);
        return result;
    }
}

export interface IMailRequest {
    userName: string | undefined;
    toEmail: string | undefined;
}

export class Media implements IMedia {
    id: number;
    type: EMediaType;
    url: string;
    paknId: number;

    constructor(data?: IMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.url = _data["url"];
            this.paknId = _data["paknId"];
        }
    }

    static fromJS(data: any): Media {
        data = typeof data === 'object' ? data : {};
        let result = new Media();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["url"] = this.url;
        data["paknId"] = this.paknId;
        return data; 
    }

    clone(): Media {
        const json = this.toJSON();
        let result = new Media();
        result.init(json);
        return result;
    }
}

export interface IMedia {
    id: number;
    type: EMediaType;
    url: string;
    paknId: number;
}

export class MediaDto implements IMediaDto {
    id: number;
    url: string | undefined;
    paknId: number;
    type: EMediaType;

    constructor(data?: IMediaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.paknId = _data["paknId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): MediaDto {
        data = typeof data === 'object' ? data : {};
        let result = new MediaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["paknId"] = this.paknId;
        data["type"] = this.type;
        return data; 
    }

    clone(): MediaDto {
        const json = this.toJSON();
        let result = new MediaDto();
        result.init(json);
        return result;
    }
}

export interface IMediaDto {
    id: number;
    url: string | undefined;
    paknId: number;
    type: EMediaType;
}

export class NhacViec implements INhacViec {
    id: number;
    tieuDe: string;
    noiDung: string;
    ngayGui: moment.Moment | undefined;
    ngayTao: moment.Moment | undefined;
    state: ENhacViecState;
    isReaded: boolean;

    constructor(data?: INhacViec) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tieuDe = _data["tieuDe"];
            this.noiDung = _data["noiDung"];
            this.ngayGui = _data["ngayGui"] ? moment(_data["ngayGui"].toString()) : <any>undefined;
            this.ngayTao = _data["ngayTao"] ? moment(_data["ngayTao"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.isReaded = _data["isReaded"];
        }
    }

    static fromJS(data: any): NhacViec {
        data = typeof data === 'object' ? data : {};
        let result = new NhacViec();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tieuDe"] = this.tieuDe;
        data["noiDung"] = this.noiDung;
        data["ngayGui"] = this.ngayGui ? this.ngayGui.toISOString() : <any>undefined;
        data["ngayTao"] = this.ngayTao ? this.ngayTao.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["isReaded"] = this.isReaded;
        return data; 
    }

    clone(): NhacViec {
        const json = this.toJSON();
        let result = new NhacViec();
        result.init(json);
        return result;
    }
}

export interface INhacViec {
    id: number;
    tieuDe: string;
    noiDung: string;
    ngayGui: moment.Moment | undefined;
    ngayTao: moment.Moment | undefined;
    state: ENhacViecState;
    isReaded: boolean;
}

export enum NhacViecType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class NhacViecViewDto implements INhacViecViewDto {
    id: number;
    tieuDe: string;
    noiDung: string;
    ngayGui: moment.Moment | undefined;
    ngayTao: moment.Moment | undefined;
    state: ENhacViecState;
    isReaded: boolean;
    userIds: number[] | undefined;
    tenNguoiDung: string[] | undefined;
    roleId: number;
    userOrg: string[] | undefined;

    constructor(data?: INhacViecViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tieuDe = _data["tieuDe"];
            this.noiDung = _data["noiDung"];
            this.ngayGui = _data["ngayGui"] ? moment(_data["ngayGui"].toString()) : <any>undefined;
            this.ngayTao = _data["ngayTao"] ? moment(_data["ngayTao"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.isReaded = _data["isReaded"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds.push(item);
            }
            if (Array.isArray(_data["tenNguoiDung"])) {
                this.tenNguoiDung = [] as any;
                for (let item of _data["tenNguoiDung"])
                    this.tenNguoiDung.push(item);
            }
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["userOrg"])) {
                this.userOrg = [] as any;
                for (let item of _data["userOrg"])
                    this.userOrg.push(item);
            }
        }
    }

    static fromJS(data: any): NhacViecViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhacViecViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tieuDe"] = this.tieuDe;
        data["noiDung"] = this.noiDung;
        data["ngayGui"] = this.ngayGui ? this.ngayGui.toISOString() : <any>undefined;
        data["ngayTao"] = this.ngayTao ? this.ngayTao.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["isReaded"] = this.isReaded;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        if (Array.isArray(this.tenNguoiDung)) {
            data["tenNguoiDung"] = [];
            for (let item of this.tenNguoiDung)
                data["tenNguoiDung"].push(item);
        }
        data["roleId"] = this.roleId;
        if (Array.isArray(this.userOrg)) {
            data["userOrg"] = [];
            for (let item of this.userOrg)
                data["userOrg"].push(item);
        }
        return data; 
    }

    clone(): NhacViecViewDto {
        const json = this.toJSON();
        let result = new NhacViecViewDto();
        result.init(json);
        return result;
    }
}

export interface INhacViecViewDto {
    id: number;
    tieuDe: string;
    noiDung: string;
    ngayGui: moment.Moment | undefined;
    ngayTao: moment.Moment | undefined;
    state: ENhacViecState;
    isReaded: boolean;
    userIds: number[] | undefined;
    tenNguoiDung: string[] | undefined;
    roleId: number;
    userOrg: string[] | undefined;
}

export class NhacViecViewDtoPagedResultDto implements INhacViecViewDtoPagedResultDto {
    items: NhacViecViewDto[] | undefined;
    totalCount: number;

    constructor(data?: INhacViecViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NhacViecViewDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NhacViecViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhacViecViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): NhacViecViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NhacViecViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INhacViecViewDtoPagedResultDto {
    items: NhacViecViewDto[] | undefined;
    totalCount: number;
}

export class NhacviecDto implements INhacviecDto {
    id: number;
    tieuDe: string;
    noiDung: string;
    ngayGui: moment.Moment | undefined;
    ngayTao: moment.Moment | undefined;
    state: ENhacViecState;
    isReaded: boolean;
    userIds: number[] | undefined;
    roleId: number;
    userOrg: string[] | undefined;

    constructor(data?: INhacviecDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tieuDe = _data["tieuDe"];
            this.noiDung = _data["noiDung"];
            this.ngayGui = _data["ngayGui"] ? moment(_data["ngayGui"].toString()) : <any>undefined;
            this.ngayTao = _data["ngayTao"] ? moment(_data["ngayTao"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.isReaded = _data["isReaded"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds.push(item);
            }
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["userOrg"])) {
                this.userOrg = [] as any;
                for (let item of _data["userOrg"])
                    this.userOrg.push(item);
            }
        }
    }

    static fromJS(data: any): NhacviecDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhacviecDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tieuDe"] = this.tieuDe;
        data["noiDung"] = this.noiDung;
        data["ngayGui"] = this.ngayGui ? this.ngayGui.toISOString() : <any>undefined;
        data["ngayTao"] = this.ngayTao ? this.ngayTao.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["isReaded"] = this.isReaded;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["roleId"] = this.roleId;
        if (Array.isArray(this.userOrg)) {
            data["userOrg"] = [];
            for (let item of this.userOrg)
                data["userOrg"].push(item);
        }
        return data; 
    }

    clone(): NhacviecDto {
        const json = this.toJSON();
        let result = new NhacviecDto();
        result.init(json);
        return result;
    }
}

export interface INhacviecDto {
    id: number;
    tieuDe: string;
    noiDung: string;
    ngayGui: moment.Moment | undefined;
    ngayTao: moment.Moment | undefined;
    state: ENhacViecState;
    isReaded: boolean;
    userIds: number[] | undefined;
    roleId: number;
    userOrg: string[] | undefined;
}

export class NhiemVu implements INhiemVu {
    id: number;
    tenNhiemVu: string | undefined;

    constructor(data?: INhiemVu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenNhiemVu = _data["tenNhiemVu"];
        }
    }

    static fromJS(data: any): NhiemVu {
        data = typeof data === 'object' ? data : {};
        let result = new NhiemVu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenNhiemVu"] = this.tenNhiemVu;
        return data; 
    }

    clone(): NhiemVu {
        const json = this.toJSON();
        let result = new NhiemVu();
        result.init(json);
        return result;
    }
}

export interface INhiemVu {
    id: number;
    tenNhiemVu: string | undefined;
}

export class NhiemVuInputDto implements INhiemVuInputDto {
    id: number;
    tenNhiemVu: string | undefined;

    constructor(data?: INhiemVuInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenNhiemVu = _data["tenNhiemVu"];
        }
    }

    static fromJS(data: any): NhiemVuInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhiemVuInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenNhiemVu"] = this.tenNhiemVu;
        return data; 
    }

    clone(): NhiemVuInputDto {
        const json = this.toJSON();
        let result = new NhiemVuInputDto();
        result.init(json);
        return result;
    }
}

export interface INhiemVuInputDto {
    id: number;
    tenNhiemVu: string | undefined;
}

export class NhiemVuPagedResultDto implements INhiemVuPagedResultDto {
    items: NhiemVu[] | undefined;
    totalCount: number;

    constructor(data?: INhiemVuPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NhiemVu.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NhiemVuPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhiemVuPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): NhiemVuPagedResultDto {
        const json = this.toJSON();
        let result = new NhiemVuPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INhiemVuPagedResultDto {
    items: NhiemVu[] | undefined;
    totalCount: number;
}

export class Notify implements INotify {
    id: number;
    userId: number | undefined;
    tieuDe: string | undefined;
    noiDung: string | undefined;
    ngayNhac: moment.Moment;
    doiTuongId: number;
    isRead: boolean;
    nhacViecPaknId: number;
    isSend: boolean;
    isBaoCao: boolean;

    constructor(data?: INotify) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.tieuDe = _data["tieuDe"];
            this.noiDung = _data["noiDung"];
            this.ngayNhac = _data["ngayNhac"] ? moment(_data["ngayNhac"].toString()) : <any>undefined;
            this.doiTuongId = _data["doiTuongId"];
            this.isRead = _data["isRead"];
            this.nhacViecPaknId = _data["nhacViecPaknId"];
            this.isSend = _data["isSend"];
            this.isBaoCao = _data["isBaoCao"];
        }
    }

    static fromJS(data: any): Notify {
        data = typeof data === 'object' ? data : {};
        let result = new Notify();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["tieuDe"] = this.tieuDe;
        data["noiDung"] = this.noiDung;
        data["ngayNhac"] = this.ngayNhac ? this.ngayNhac.toISOString() : <any>undefined;
        data["doiTuongId"] = this.doiTuongId;
        data["isRead"] = this.isRead;
        data["nhacViecPaknId"] = this.nhacViecPaknId;
        data["isSend"] = this.isSend;
        data["isBaoCao"] = this.isBaoCao;
        return data; 
    }

    clone(): Notify {
        const json = this.toJSON();
        let result = new Notify();
        result.init(json);
        return result;
    }
}

export interface INotify {
    id: number;
    userId: number | undefined;
    tieuDe: string | undefined;
    noiDung: string | undefined;
    ngayNhac: moment.Moment;
    doiTuongId: number;
    isRead: boolean;
    nhacViecPaknId: number;
    isSend: boolean;
    isBaoCao: boolean;
}

export class NotifyDto implements INotifyDto {
    notifys: Notify[] | undefined;
    isCountReaded: number;

    constructor(data?: INotifyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notifys"])) {
                this.notifys = [] as any;
                for (let item of _data["notifys"])
                    this.notifys.push(Notify.fromJS(item));
            }
            this.isCountReaded = _data["isCountReaded"];
        }
    }

    static fromJS(data: any): NotifyDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotifyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notifys)) {
            data["notifys"] = [];
            for (let item of this.notifys)
                data["notifys"].push(item.toJSON());
        }
        data["isCountReaded"] = this.isCountReaded;
        return data; 
    }

    clone(): NotifyDto {
        const json = this.toJSON();
        let result = new NotifyDto();
        result.init(json);
        return result;
    }
}

export interface INotifyDto {
    notifys: Notify[] | undefined;
    isCountReaded: number;
}

export class ObjNotification implements IObjNotification {
    registration_ids: string[] | undefined;
    title: string | undefined;
    body: string | undefined;

    constructor(data?: IObjNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["registration_ids"])) {
                this.registration_ids = [] as any;
                for (let item of _data["registration_ids"])
                    this.registration_ids.push(item);
            }
            this.title = _data["title"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): ObjNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ObjNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.registration_ids)) {
            data["registration_ids"] = [];
            for (let item of this.registration_ids)
                data["registration_ids"].push(item);
        }
        data["title"] = this.title;
        data["body"] = this.body;
        return data; 
    }

    clone(): ObjNotification {
        const json = this.toJSON();
        let result = new ObjNotification();
        result.init(json);
        return result;
    }
}

export interface IObjNotification {
    registration_ids: string[] | undefined;
    title: string | undefined;
    body: string | undefined;
}

export enum OgcGeometryType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
}

export enum Ordinates {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _65535 = 65535,
    _65536 = 65536,
    _65539 = 65539,
    _65543 = 65543,
    _131072 = 131072,
    _262144 = 262144,
    _524288 = 524288,
    _1048576 = 1048576,
    _2097152 = 2097152,
    _4194304 = 4194304,
    _8388608 = 8388608,
    _16777216 = 16777216,
    _33554432 = 33554432,
    _67108864 = 67108864,
    _134217728 = 134217728,
    _268435456 = 268435456,
    _536870912 = 536870912,
    _1073741824 = 1073741824,
    __2147483648 = -2147483648,
    __65536 = -65536,
    __1 = -1,
}

export class OrganizationUnit implements IOrganizationUnit {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number | undefined;
    parent: OrganizationUnit;
    parentId: number | undefined;
    code: string;
    displayName: string;
    children: OrganizationUnit[] | undefined;

    constructor(data?: IOrganizationUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.parent = _data["parent"] ? OrganizationUnit.fromJS(_data["parent"]) : <any>undefined;
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(OrganizationUnit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnit {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OrganizationUnit {
        const json = this.toJSON();
        let result = new OrganizationUnit();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnit {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number | undefined;
    parent: OrganizationUnit;
    parentId: number | undefined;
    code: string;
    displayName: string;
    children: OrganizationUnit[] | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    id: number;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    address: string | undefined;
    organizationCode: string | undefined;
    diaBanId: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
            this.address = _data["address"];
            this.organizationCode = _data["organizationCode"];
            this.diaBanId = _data["diaBanId"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["address"] = this.address;
        data["organizationCode"] = this.organizationCode;
        data["diaBanId"] = this.diaBanId;
        return data; 
    }

    clone(): OrganizationUnitDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDto {
    id: number;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    address: string | undefined;
    organizationCode: string | undefined;
    diaBanId: number | undefined;
}

export class OrganizationUnitDtoListResultDto implements IOrganizationUnitDtoListResultDto {
    items: OrganizationUnitDto[] | undefined;

    constructor(data?: IOrganizationUnitDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OrganizationUnitDtoListResultDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDtoListResultDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationViewDto implements IOrganizationViewDto {
    id: number;
    displayName: string | undefined;

    constructor(data?: IOrganizationViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): OrganizationViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): OrganizationViewDto {
        const json = this.toJSON();
        let result = new OrganizationViewDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationViewDto {
    id: number;
    displayName: string | undefined;
}

export class OrganizationViewTreeDto implements IOrganizationViewTreeDto {
    value: number;
    parentId: number | undefined;
    text: string | undefined;
    children: OrganizationViewTreeDto[] | undefined;

    constructor(data?: IOrganizationViewTreeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.parentId = _data["parentId"];
            this.text = _data["text"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(OrganizationViewTreeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationViewTreeDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationViewTreeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["parentId"] = this.parentId;
        data["text"] = this.text;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OrganizationViewTreeDto {
        const json = this.toJSON();
        let result = new OrganizationViewTreeDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationViewTreeDto {
    value: number;
    parentId: number | undefined;
    text: string | undefined;
    children: OrganizationViewTreeDto[] | undefined;
}

export class OrganizationsUnit implements IOrganizationsUnit {
    id: number;
    tenantId: number;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    isDeleted: boolean;
    diaBanId: number | undefined;
    address: string | undefined;
    orgCode: string | undefined;
    maTinh: string | undefined;
    maHuyen: string | undefined;
    maXa: string | undefined;

    constructor(data?: IOrganizationsUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.isDeleted = _data["isDeleted"];
            this.diaBanId = _data["diaBanId"];
            this.address = _data["address"];
            this.orgCode = _data["orgCode"];
            this.maTinh = _data["maTinh"];
            this.maHuyen = _data["maHuyen"];
            this.maXa = _data["maXa"];
        }
    }

    static fromJS(data: any): OrganizationsUnit {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationsUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["isDeleted"] = this.isDeleted;
        data["diaBanId"] = this.diaBanId;
        data["address"] = this.address;
        data["orgCode"] = this.orgCode;
        data["maTinh"] = this.maTinh;
        data["maHuyen"] = this.maHuyen;
        data["maXa"] = this.maXa;
        return data; 
    }

    clone(): OrganizationsUnit {
        const json = this.toJSON();
        let result = new OrganizationsUnit();
        result.init(json);
        return result;
    }
}

export interface IOrganizationsUnit {
    id: number;
    tenantId: number;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    isDeleted: boolean;
    diaBanId: number | undefined;
    address: string | undefined;
    orgCode: string | undefined;
    maTinh: string | undefined;
    maHuyen: string | undefined;
    maXa: string | undefined;
}

export class PAKNDto implements IPAKNDto {
    id: number;
    title: string | undefined;
    content: string | undefined;
    paTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    geom: string | undefined;
    kienNghi: string | undefined;
    idUserSend: number | undefined;
    state: EnumPaknState;
    doiTuongId: number;
    tenDoiTuong: string | undefined;
    stateName: string | undefined;
    noiDungPheDuyet: string | undefined;
    paknOrg: string[] | undefined;
    tenToChuc: string | undefined;
    lat: number;
    lng: number;
    organizationUnitId: number | undefined;
    medias: Media[] | undefined;
    images: Media[] | undefined;
    files: Media[] | undefined;
    type: EnumPaknType;
    ma_dvhc_t: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_x: string | undefined;
    suKienId: number;
    diaChi: string | undefined;
    ngayBaoCao: moment.Moment | undefined;
    userId: number;

    constructor(data?: IPAKNDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.paTime = _data["paTime"] ? moment(_data["paTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.geom = _data["geom"];
            this.kienNghi = _data["kienNghi"];
            this.idUserSend = _data["idUserSend"];
            this.state = _data["state"];
            this.doiTuongId = _data["doiTuongId"];
            this.tenDoiTuong = _data["tenDoiTuong"];
            this.stateName = _data["stateName"];
            this.noiDungPheDuyet = _data["noiDungPheDuyet"];
            if (Array.isArray(_data["paknOrg"])) {
                this.paknOrg = [] as any;
                for (let item of _data["paknOrg"])
                    this.paknOrg.push(item);
            }
            this.tenToChuc = _data["tenToChuc"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["medias"])) {
                this.medias = [] as any;
                for (let item of _data["medias"])
                    this.medias.push(Media.fromJS(item));
            }
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images.push(Media.fromJS(item));
            }
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files.push(Media.fromJS(item));
            }
            this.type = _data["type"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
            this.ma_dvhc_h = _data["ma_dvhc_h"];
            this.ma_dvhc_x = _data["ma_dvhc_x"];
            this.suKienId = _data["suKienId"];
            this.diaChi = _data["diaChi"];
            this.ngayBaoCao = _data["ngayBaoCao"] ? moment(_data["ngayBaoCao"].toString()) : <any>undefined;
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): PAKNDto {
        data = typeof data === 'object' ? data : {};
        let result = new PAKNDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["paTime"] = this.paTime ? this.paTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["geom"] = this.geom;
        data["kienNghi"] = this.kienNghi;
        data["idUserSend"] = this.idUserSend;
        data["state"] = this.state;
        data["doiTuongId"] = this.doiTuongId;
        data["tenDoiTuong"] = this.tenDoiTuong;
        data["stateName"] = this.stateName;
        data["noiDungPheDuyet"] = this.noiDungPheDuyet;
        if (Array.isArray(this.paknOrg)) {
            data["paknOrg"] = [];
            for (let item of this.paknOrg)
                data["paknOrg"].push(item);
        }
        data["tenToChuc"] = this.tenToChuc;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.medias)) {
            data["medias"] = [];
            for (let item of this.medias)
                data["medias"].push(item.toJSON());
        }
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["type"] = this.type;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        data["ma_dvhc_h"] = this.ma_dvhc_h;
        data["ma_dvhc_x"] = this.ma_dvhc_x;
        data["suKienId"] = this.suKienId;
        data["diaChi"] = this.diaChi;
        data["ngayBaoCao"] = this.ngayBaoCao ? this.ngayBaoCao.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): PAKNDto {
        const json = this.toJSON();
        let result = new PAKNDto();
        result.init(json);
        return result;
    }
}

export interface IPAKNDto {
    id: number;
    title: string | undefined;
    content: string | undefined;
    paTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    geom: string | undefined;
    kienNghi: string | undefined;
    idUserSend: number | undefined;
    state: EnumPaknState;
    doiTuongId: number;
    tenDoiTuong: string | undefined;
    stateName: string | undefined;
    noiDungPheDuyet: string | undefined;
    paknOrg: string[] | undefined;
    tenToChuc: string | undefined;
    lat: number;
    lng: number;
    organizationUnitId: number | undefined;
    medias: Media[] | undefined;
    images: Media[] | undefined;
    files: Media[] | undefined;
    type: EnumPaknType;
    ma_dvhc_t: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_x: string | undefined;
    suKienId: number;
    diaChi: string | undefined;
    ngayBaoCao: moment.Moment | undefined;
    userId: number;
}

export class PAKNDtoPagedResultDto implements IPAKNDtoPagedResultDto {
    items: PAKNDto[] | undefined;
    totalCount: number;

    constructor(data?: IPAKNDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PAKNDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PAKNDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PAKNDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PAKNDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PAKNDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPAKNDtoPagedResultDto {
    items: PAKNDto[] | undefined;
    totalCount: number;
}

export class PAKNMedia implements IPAKNMedia {
    id: number;
    type: number;
    url: string | undefined;
    paknId: number;

    constructor(data?: IPAKNMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.url = _data["url"];
            this.paknId = _data["paknId"];
        }
    }

    static fromJS(data: any): PAKNMedia {
        data = typeof data === 'object' ? data : {};
        let result = new PAKNMedia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["url"] = this.url;
        data["paknId"] = this.paknId;
        return data; 
    }

    clone(): PAKNMedia {
        const json = this.toJSON();
        let result = new PAKNMedia();
        result.init(json);
        return result;
    }
}

export interface IPAKNMedia {
    id: number;
    type: number;
    url: string | undefined;
    paknId: number;
}

export class PAKNSForMap implements IPAKNSForMap {
    id: number;
    state: number;
    lat: number;
    lng: number;

    constructor(data?: IPAKNSForMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
        }
    }

    static fromJS(data: any): PAKNSForMap {
        data = typeof data === 'object' ? data : {};
        let result = new PAKNSForMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        return data; 
    }

    clone(): PAKNSForMap {
        const json = this.toJSON();
        let result = new PAKNSForMap();
        result.init(json);
        return result;
    }
}

export interface IPAKNSForMap {
    id: number;
    state: number;
    lat: number;
    lng: number;
}

export class PAKNTypeDto implements IPAKNTypeDto {
    id: number;
    name: string | undefined;

    constructor(data?: IPAKNTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PAKNTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PAKNTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): PAKNTypeDto {
        const json = this.toJSON();
        let result = new PAKNTypeDto();
        result.init(json);
        return result;
    }
}

export interface IPAKNTypeDto {
    id: number;
    name: string | undefined;
}

export class PAKNViewMap implements IPAKNViewMap {
    id: number;
    title: string | undefined;
    content: string | undefined;
    kienNghi: string | undefined;
    idUserSend: number;
    state: number;
    doiTuongId: number;
    history: string | undefined;
    noiDungPheDuyet: string | undefined;
    organizationUnitId: number;
    type: number;
    tenDoiTuong: string | undefined;
    tenToChuc: string | undefined;
    medias: PAKNMedia[] | undefined;
    images: PAKNMedia[] | undefined;
    files: PAKNMedia[] | undefined;
    is_success: boolean;

    constructor(data?: IPAKNViewMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.kienNghi = _data["kienNghi"];
            this.idUserSend = _data["idUserSend"];
            this.state = _data["state"];
            this.doiTuongId = _data["doiTuongId"];
            this.history = _data["history"];
            this.noiDungPheDuyet = _data["noiDungPheDuyet"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.type = _data["type"];
            this.tenDoiTuong = _data["tenDoiTuong"];
            this.tenToChuc = _data["tenToChuc"];
            if (Array.isArray(_data["medias"])) {
                this.medias = [] as any;
                for (let item of _data["medias"])
                    this.medias.push(PAKNMedia.fromJS(item));
            }
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images.push(PAKNMedia.fromJS(item));
            }
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files.push(PAKNMedia.fromJS(item));
            }
            this.is_success = _data["is_success"];
        }
    }

    static fromJS(data: any): PAKNViewMap {
        data = typeof data === 'object' ? data : {};
        let result = new PAKNViewMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["kienNghi"] = this.kienNghi;
        data["idUserSend"] = this.idUserSend;
        data["state"] = this.state;
        data["doiTuongId"] = this.doiTuongId;
        data["history"] = this.history;
        data["noiDungPheDuyet"] = this.noiDungPheDuyet;
        data["organizationUnitId"] = this.organizationUnitId;
        data["type"] = this.type;
        data["tenDoiTuong"] = this.tenDoiTuong;
        data["tenToChuc"] = this.tenToChuc;
        if (Array.isArray(this.medias)) {
            data["medias"] = [];
            for (let item of this.medias)
                data["medias"].push(item.toJSON());
        }
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["is_success"] = this.is_success;
        return data; 
    }

    clone(): PAKNViewMap {
        const json = this.toJSON();
        let result = new PAKNViewMap();
        result.init(json);
        return result;
    }
}

export interface IPAKNViewMap {
    id: number;
    title: string | undefined;
    content: string | undefined;
    kienNghi: string | undefined;
    idUserSend: number;
    state: number;
    doiTuongId: number;
    history: string | undefined;
    noiDungPheDuyet: string | undefined;
    organizationUnitId: number;
    type: number;
    tenDoiTuong: string | undefined;
    tenToChuc: string | undefined;
    medias: PAKNMedia[] | undefined;
    images: PAKNMedia[] | undefined;
    files: PAKNMedia[] | undefined;
    is_success: boolean;
}

export class PermissionDto implements IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class Point implements IPoint {
    factory: GeometryFactory;
    userData: any | undefined;
    srid: number;
    precisionModel: PrecisionModel;
    readonly numGeometries: number;
    readonly isSimple: boolean;
    readonly isValid: boolean;
    readonly area: number;
    readonly length: number;
    centroid: Point;
    interiorPoint: Point;
    pointOnSurface: Point;
    envelope: Geometry;
    envelopeInternal: Envelope;
    readonly isRectangle: boolean;
    coordinateSequence: CoordinateSequence;
    readonly coordinates: Coordinate[] | undefined;
    readonly numPoints: number;
    readonly isEmpty: boolean;
    dimension: Dimension;
    boundaryDimension: Dimension;
    x: number;
    y: number;
    coordinate: Coordinate;
    readonly geometryType: string | undefined;
    ogcGeometryType: OgcGeometryType;
    boundary: Geometry;
    z: number;
    m: number;

    constructor(data?: IPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.factory = _data["factory"] ? GeometryFactory.fromJS(_data["factory"]) : <any>undefined;
            this.userData = _data["userData"];
            this.srid = _data["srid"];
            this.precisionModel = _data["precisionModel"] ? PrecisionModel.fromJS(_data["precisionModel"]) : <any>undefined;
            (<any>this).numGeometries = _data["numGeometries"];
            (<any>this).isSimple = _data["isSimple"];
            (<any>this).isValid = _data["isValid"];
            (<any>this).area = _data["area"];
            (<any>this).length = _data["length"];
            this.centroid = _data["centroid"] ? Point.fromJS(_data["centroid"]) : <any>undefined;
            this.interiorPoint = _data["interiorPoint"] ? Point.fromJS(_data["interiorPoint"]) : <any>undefined;
            this.pointOnSurface = _data["pointOnSurface"] ? Point.fromJS(_data["pointOnSurface"]) : <any>undefined;
            this.envelope = _data["envelope"] ? Geometry.fromJS(_data["envelope"]) : <any>undefined;
            this.envelopeInternal = _data["envelopeInternal"] ? Envelope.fromJS(_data["envelopeInternal"]) : <any>undefined;
            (<any>this).isRectangle = _data["isRectangle"];
            this.coordinateSequence = _data["coordinateSequence"] ? CoordinateSequence.fromJS(_data["coordinateSequence"]) : <any>undefined;
            if (Array.isArray(_data["coordinates"])) {
                (<any>this).coordinates = [] as any;
                for (let item of _data["coordinates"])
                    (<any>this).coordinates.push(Coordinate.fromJS(item));
            }
            (<any>this).numPoints = _data["numPoints"];
            (<any>this).isEmpty = _data["isEmpty"];
            this.dimension = _data["dimension"];
            this.boundaryDimension = _data["boundaryDimension"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.coordinate = _data["coordinate"] ? Coordinate.fromJS(_data["coordinate"]) : <any>undefined;
            (<any>this).geometryType = _data["geometryType"];
            this.ogcGeometryType = _data["ogcGeometryType"];
            this.boundary = _data["boundary"] ? Geometry.fromJS(_data["boundary"]) : <any>undefined;
            this.z = _data["z"];
            this.m = _data["m"];
        }
    }

    static fromJS(data: any): Point {
        data = typeof data === 'object' ? data : {};
        let result = new Point();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["factory"] = this.factory ? this.factory.toJSON() : <any>undefined;
        data["userData"] = this.userData;
        data["srid"] = this.srid;
        data["precisionModel"] = this.precisionModel ? this.precisionModel.toJSON() : <any>undefined;
        data["numGeometries"] = this.numGeometries;
        data["isSimple"] = this.isSimple;
        data["isValid"] = this.isValid;
        data["area"] = this.area;
        data["length"] = this.length;
        data["centroid"] = this.centroid ? this.centroid.toJSON() : <any>undefined;
        data["interiorPoint"] = this.interiorPoint ? this.interiorPoint.toJSON() : <any>undefined;
        data["pointOnSurface"] = this.pointOnSurface ? this.pointOnSurface.toJSON() : <any>undefined;
        data["envelope"] = this.envelope ? this.envelope.toJSON() : <any>undefined;
        data["envelopeInternal"] = this.envelopeInternal ? this.envelopeInternal.toJSON() : <any>undefined;
        data["isRectangle"] = this.isRectangle;
        data["coordinateSequence"] = this.coordinateSequence ? this.coordinateSequence.toJSON() : <any>undefined;
        if (Array.isArray(this.coordinates)) {
            data["coordinates"] = [];
            for (let item of this.coordinates)
                data["coordinates"].push(item.toJSON());
        }
        data["numPoints"] = this.numPoints;
        data["isEmpty"] = this.isEmpty;
        data["dimension"] = this.dimension;
        data["boundaryDimension"] = this.boundaryDimension;
        data["x"] = this.x;
        data["y"] = this.y;
        data["coordinate"] = this.coordinate ? this.coordinate.toJSON() : <any>undefined;
        data["geometryType"] = this.geometryType;
        data["ogcGeometryType"] = this.ogcGeometryType;
        data["boundary"] = this.boundary ? this.boundary.toJSON() : <any>undefined;
        data["z"] = this.z;
        data["m"] = this.m;
        return data; 
    }

    clone(): Point {
        const json = this.toJSON();
        let result = new Point();
        result.init(json);
        return result;
    }
}

export interface IPoint {
    factory: GeometryFactory;
    userData: any | undefined;
    srid: number;
    precisionModel: PrecisionModel;
    numGeometries: number;
    isSimple: boolean;
    isValid: boolean;
    area: number;
    length: number;
    centroid: Point;
    interiorPoint: Point;
    pointOnSurface: Point;
    envelope: Geometry;
    envelopeInternal: Envelope;
    isRectangle: boolean;
    coordinateSequence: CoordinateSequence;
    coordinates: Coordinate[] | undefined;
    numPoints: number;
    isEmpty: boolean;
    dimension: Dimension;
    boundaryDimension: Dimension;
    x: number;
    y: number;
    coordinate: Coordinate;
    geometryType: string | undefined;
    ogcGeometryType: OgcGeometryType;
    boundary: Geometry;
    z: number;
    m: number;
}

export class PrecisionModel implements IPrecisionModel {
    readonly isFloating: boolean;
    readonly maximumSignificantDigits: number;
    scale: number;
    precisionModelType: PrecisionModels;

    constructor(data?: IPrecisionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isFloating = _data["isFloating"];
            (<any>this).maximumSignificantDigits = _data["maximumSignificantDigits"];
            this.scale = _data["scale"];
            this.precisionModelType = _data["precisionModelType"];
        }
    }

    static fromJS(data: any): PrecisionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PrecisionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFloating"] = this.isFloating;
        data["maximumSignificantDigits"] = this.maximumSignificantDigits;
        data["scale"] = this.scale;
        data["precisionModelType"] = this.precisionModelType;
        return data; 
    }

    clone(): PrecisionModel {
        const json = this.toJSON();
        let result = new PrecisionModel();
        result.init(json);
        return result;
    }
}

export interface IPrecisionModel {
    isFloating: boolean;
    maximumSignificantDigits: number;
    scale: number;
    precisionModelType: PrecisionModels;
}

export enum PrecisionModels {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
    ngayBatDau: moment.Moment;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
            this.ngayBatDau = _data["ngayBatDau"] ? moment(_data["ngayBatDau"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        data["ngayBatDau"] = this.ngayBatDau ? this.ngayBatDau.toISOString() : <any>undefined;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
    ngayBatDau: moment.Moment;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class Role implements IRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number | undefined;
    name: string;
    displayName: string;
    isStatic: boolean;
    isDefault: boolean;
    permissions: RolePermissionSetting[] | undefined;
    normalizedName: string;
    claims: RoleClaim[] | undefined;
    concurrencyStamp: string | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    description: string | undefined;
    roleCode: string | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(RolePermissionSetting.fromJS(item));
            }
            this.normalizedName = _data["normalizedName"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(RoleClaim.fromJS(item));
            }
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.description = _data["description"];
            this.roleCode = _data["roleCode"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["normalizedName"] = this.normalizedName;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["roleCode"] = this.roleCode;
        return data; 
    }

    clone(): Role {
        const json = this.toJSON();
        let result = new Role();
        result.init(json);
        return result;
    }
}

export interface IRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number | undefined;
    name: string;
    displayName: string;
    isStatic: boolean;
    isDefault: boolean;
    permissions: RolePermissionSetting[] | undefined;
    normalizedName: string;
    claims: RoleClaim[] | undefined;
    concurrencyStamp: string | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    description: string | undefined;
    roleCode: string | undefined;
}

export class RoleClaim implements IRoleClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    roleId: number;
    claimType: string | undefined;
    claimValue: string | undefined;

    constructor(data?: IRoleClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.roleId = _data["roleId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): RoleClaim {
        data = typeof data === 'object' ? data : {};
        let result = new RoleClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["roleId"] = this.roleId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data; 
    }

    clone(): RoleClaim {
        const json = this.toJSON();
        let result = new RoleClaim();
        result.init(json);
        return result;
    }
}

export interface IRoleClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    roleId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
}

export class RoleDto implements IRoleDto {
    id: number;
    name: string;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    name: string;
    displayName: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
    id: number;
    name: string;
    displayName: string | undefined;
    description: string | undefined;
    isStatic: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number;
    name: string;
    displayName: string | undefined;
    description: string | undefined;
    isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class RolePermissionSetting implements IRolePermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    roleId: number;

    constructor(data?: IRolePermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): RolePermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["roleId"] = this.roleId;
        return data; 
    }

    clone(): RolePermissionSetting {
        const json = this.toJSON();
        let result = new RolePermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    roleId: number;
}

export class RoleViewDto implements IRoleViewDto {
    chucNang: string[] | undefined;

    constructor(data?: IRoleViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chucNang"])) {
                this.chucNang = [] as any;
                for (let item of _data["chucNang"])
                    this.chucNang.push(item);
            }
        }
    }

    static fromJS(data: any): RoleViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chucNang)) {
            data["chucNang"] = [];
            for (let item of this.chucNang)
                data["chucNang"].push(item);
        }
        return data; 
    }

    clone(): RoleViewDto {
        const json = this.toJSON();
        let result = new RoleViewDto();
        result.init(json);
        return result;
    }
}

export interface IRoleViewDto {
    chucNang: string[] | undefined;
}

export class RoleViewDtoListResultDto implements IRoleViewDtoListResultDto {
    items: RoleViewDto[] | undefined;

    constructor(data?: IRoleViewDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleViewDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleViewDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleViewDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleViewDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleViewDtoListResultDto {
    items: RoleViewDto[] | undefined;
}

export class SearchDto implements ISearchDto {
    id: number;
    title: string | undefined;
    content: string | undefined;
    paTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    geom: string | undefined;
    kienNghi: string | undefined;
    idUserSend: number | undefined;
    state: EnumPaknState;
    doiTuongId: number;
    tenDoiTuong: string | undefined;
    stateName: string | undefined;
    noiDungPheDuyet: string | undefined;
    paknOrg: string[] | undefined;
    idToChuc: number;
    tenToChuc: string | undefined;

    constructor(data?: ISearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.paTime = _data["paTime"] ? moment(_data["paTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.geom = _data["geom"];
            this.kienNghi = _data["kienNghi"];
            this.idUserSend = _data["idUserSend"];
            this.state = _data["state"];
            this.doiTuongId = _data["doiTuongId"];
            this.tenDoiTuong = _data["tenDoiTuong"];
            this.stateName = _data["stateName"];
            this.noiDungPheDuyet = _data["noiDungPheDuyet"];
            if (Array.isArray(_data["paknOrg"])) {
                this.paknOrg = [] as any;
                for (let item of _data["paknOrg"])
                    this.paknOrg.push(item);
            }
            this.idToChuc = _data["idToChuc"];
            this.tenToChuc = _data["tenToChuc"];
        }
    }

    static fromJS(data: any): SearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["paTime"] = this.paTime ? this.paTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["geom"] = this.geom;
        data["kienNghi"] = this.kienNghi;
        data["idUserSend"] = this.idUserSend;
        data["state"] = this.state;
        data["doiTuongId"] = this.doiTuongId;
        data["tenDoiTuong"] = this.tenDoiTuong;
        data["stateName"] = this.stateName;
        data["noiDungPheDuyet"] = this.noiDungPheDuyet;
        if (Array.isArray(this.paknOrg)) {
            data["paknOrg"] = [];
            for (let item of this.paknOrg)
                data["paknOrg"].push(item);
        }
        data["idToChuc"] = this.idToChuc;
        data["tenToChuc"] = this.tenToChuc;
        return data; 
    }

    clone(): SearchDto {
        const json = this.toJSON();
        let result = new SearchDto();
        result.init(json);
        return result;
    }
}

export interface ISearchDto {
    id: number;
    title: string | undefined;
    content: string | undefined;
    paTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    geom: string | undefined;
    kienNghi: string | undefined;
    idUserSend: number | undefined;
    state: EnumPaknState;
    doiTuongId: number;
    tenDoiTuong: string | undefined;
    stateName: string | undefined;
    noiDungPheDuyet: string | undefined;
    paknOrg: string[] | undefined;
    idToChuc: number;
    tenToChuc: string | undefined;
}

export class SearchDtoPagedResultDto implements ISearchDtoPagedResultDto {
    items: SearchDto[] | undefined;
    totalCount: number;

    constructor(data?: ISearchDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SearchDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SearchDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SearchDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SearchDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISearchDtoPagedResultDto {
    items: SearchDto[] | undefined;
    totalCount: number;
}

export class Setting implements ISetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
}

export class StateDto implements IStateDto {
    id: number;
    name: string | undefined;

    constructor(data?: IStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): StateDto {
        data = typeof data === 'object' ? data : {};
        let result = new StateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): StateDto {
        const json = this.toJSON();
        let result = new StateDto();
        result.init(json);
        return result;
    }
}

export interface IStateDto {
    id: number;
    name: string | undefined;
}

export class SuKien implements ISuKien {
    id: number;
    tenSuKien: string | undefined;
    isDelete: boolean;

    constructor(data?: ISuKien) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenSuKien = _data["tenSuKien"];
            this.isDelete = _data["isDelete"];
        }
    }

    static fromJS(data: any): SuKien {
        data = typeof data === 'object' ? data : {};
        let result = new SuKien();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenSuKien"] = this.tenSuKien;
        data["isDelete"] = this.isDelete;
        return data; 
    }

    clone(): SuKien {
        const json = this.toJSON();
        let result = new SuKien();
        result.init(json);
        return result;
    }
}

export interface ISuKien {
    id: number;
    tenSuKien: string | undefined;
    isDelete: boolean;
}

export class SuKienInputDto implements ISuKienInputDto {
    id: number;
    tenSuKien: string | undefined;

    constructor(data?: ISuKienInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenSuKien = _data["tenSuKien"];
        }
    }

    static fromJS(data: any): SuKienInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SuKienInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenSuKien"] = this.tenSuKien;
        return data; 
    }

    clone(): SuKienInputDto {
        const json = this.toJSON();
        let result = new SuKienInputDto();
        result.init(json);
        return result;
    }
}

export interface ISuKienInputDto {
    id: number;
    tenSuKien: string | undefined;
}

export class SuKienPagedResultDto implements ISuKienPagedResultDto {
    items: SuKien[] | undefined;
    totalCount: number;

    constructor(data?: ISuKienPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SuKien.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SuKienPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SuKienPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SuKienPagedResultDto {
        const json = this.toJSON();
        let result = new SuKienPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISuKienPagedResultDto {
    items: SuKien[] | undefined;
    totalCount: number;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantDto implements ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class ThongBaoNhacViecDto implements IThongBaoNhacViecDto {
    userIds: number;
    tenNguoiDung: string | undefined;
    thongBao: NhacViec[] | undefined;
    countIsNotReaded: number;

    constructor(data?: IThongBaoNhacViecDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userIds = _data["userIds"];
            this.tenNguoiDung = _data["tenNguoiDung"];
            if (Array.isArray(_data["thongBao"])) {
                this.thongBao = [] as any;
                for (let item of _data["thongBao"])
                    this.thongBao.push(NhacViec.fromJS(item));
            }
            this.countIsNotReaded = _data["countIsNotReaded"];
        }
    }

    static fromJS(data: any): ThongBaoNhacViecDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongBaoNhacViecDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userIds"] = this.userIds;
        data["tenNguoiDung"] = this.tenNguoiDung;
        if (Array.isArray(this.thongBao)) {
            data["thongBao"] = [];
            for (let item of this.thongBao)
                data["thongBao"].push(item.toJSON());
        }
        data["countIsNotReaded"] = this.countIsNotReaded;
        return data; 
    }

    clone(): ThongBaoNhacViecDto {
        const json = this.toJSON();
        let result = new ThongBaoNhacViecDto();
        result.init(json);
        return result;
    }
}

export interface IThongBaoNhacViecDto {
    userIds: number;
    tenNguoiDung: string | undefined;
    thongBao: NhacViec[] | undefined;
    countIsNotReaded: number;
}

export class ThongKeNhacViecDto implements IThongKeNhacViecDto {
    id: number;
    userId: number | undefined;
    tieuDe: string | undefined;
    noiDung: string | undefined;
    ngayNhac: moment.Moment;
    doiTuongId: number;
    isBaoCao: boolean;
    status: string | undefined;
    userName: string | undefined;
    surname: string | undefined;
    name: string | undefined;
    tenDoiTuong: string | undefined;
    id_NguoiBaoCao: number;
    id_DoiTuong: number;

    constructor(data?: IThongKeNhacViecDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.tieuDe = _data["tieuDe"];
            this.noiDung = _data["noiDung"];
            this.ngayNhac = _data["ngayNhac"] ? moment(_data["ngayNhac"].toString()) : <any>undefined;
            this.doiTuongId = _data["doiTuongId"];
            this.isBaoCao = _data["isBaoCao"];
            this.status = _data["status"];
            this.userName = _data["userName"];
            this.surname = _data["surname"];
            this.name = _data["name"];
            this.tenDoiTuong = _data["tenDoiTuong"];
            this.id_NguoiBaoCao = _data["id_NguoiBaoCao"];
            this.id_DoiTuong = _data["id_DoiTuong"];
        }
    }

    static fromJS(data: any): ThongKeNhacViecDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeNhacViecDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["tieuDe"] = this.tieuDe;
        data["noiDung"] = this.noiDung;
        data["ngayNhac"] = this.ngayNhac ? this.ngayNhac.toISOString() : <any>undefined;
        data["doiTuongId"] = this.doiTuongId;
        data["isBaoCao"] = this.isBaoCao;
        data["status"] = this.status;
        data["userName"] = this.userName;
        data["surname"] = this.surname;
        data["name"] = this.name;
        data["tenDoiTuong"] = this.tenDoiTuong;
        data["id_NguoiBaoCao"] = this.id_NguoiBaoCao;
        data["id_DoiTuong"] = this.id_DoiTuong;
        return data; 
    }

    clone(): ThongKeNhacViecDto {
        const json = this.toJSON();
        let result = new ThongKeNhacViecDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeNhacViecDto {
    id: number;
    userId: number | undefined;
    tieuDe: string | undefined;
    noiDung: string | undefined;
    ngayNhac: moment.Moment;
    doiTuongId: number;
    isBaoCao: boolean;
    status: string | undefined;
    userName: string | undefined;
    surname: string | undefined;
    name: string | undefined;
    tenDoiTuong: string | undefined;
    id_NguoiBaoCao: number;
    id_DoiTuong: number;
}

export class ThongKeNhacViecDtoPagedResultDto implements IThongKeNhacViecDtoPagedResultDto {
    items: ThongKeNhacViecDto[] | undefined;
    totalCount: number;

    constructor(data?: IThongKeNhacViecDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ThongKeNhacViecDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ThongKeNhacViecDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeNhacViecDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ThongKeNhacViecDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ThongKeNhacViecDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IThongKeNhacViecDtoPagedResultDto {
    items: ThongKeNhacViecDto[] | undefined;
    totalCount: number;
}

export class Tinh implements ITinh {
    id: number;
    wbk_geometry: Geometry[] | undefined;
    ma_dvhc_t: string | undefined;
    ten_dvhc_t: string | undefined;
    dientich: number;
    danso: number;
    ghichu: string | undefined;
    dvhc_id: string | undefined;

    constructor(data?: ITinh) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["wbk_geometry"])) {
                this.wbk_geometry = [] as any;
                for (let item of _data["wbk_geometry"])
                    this.wbk_geometry.push(Geometry.fromJS(item));
            }
            this.ma_dvhc_t = _data["ma_dvhc_t"];
            this.ten_dvhc_t = _data["ten_dvhc_t"];
            this.dientich = _data["dientich"];
            this.danso = _data["danso"];
            this.ghichu = _data["ghichu"];
            this.dvhc_id = _data["dvhc_id"];
        }
    }

    static fromJS(data: any): Tinh {
        data = typeof data === 'object' ? data : {};
        let result = new Tinh();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.wbk_geometry)) {
            data["wbk_geometry"] = [];
            for (let item of this.wbk_geometry)
                data["wbk_geometry"].push(item.toJSON());
        }
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        data["ten_dvhc_t"] = this.ten_dvhc_t;
        data["dientich"] = this.dientich;
        data["danso"] = this.danso;
        data["ghichu"] = this.ghichu;
        data["dvhc_id"] = this.dvhc_id;
        return data; 
    }

    clone(): Tinh {
        const json = this.toJSON();
        let result = new Tinh();
        result.init(json);
        return result;
    }
}

export interface ITinh {
    id: number;
    wbk_geometry: Geometry[] | undefined;
    ma_dvhc_t: string | undefined;
    ten_dvhc_t: string | undefined;
    dientich: number;
    danso: number;
    ghichu: string | undefined;
    dvhc_id: string | undefined;
}

export class TinhDto implements ITinhDto {
    id: number;
    wbk_geometry: string | undefined;
    ma_dvhc_t: string | undefined;
    ten_dvhc_t: string | undefined;
    dientich: number;
    danso: number;
    ghichu: string | undefined;

    constructor(data?: ITinhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.wbk_geometry = _data["wbk_geometry"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
            this.ten_dvhc_t = _data["ten_dvhc_t"];
            this.dientich = _data["dientich"];
            this.danso = _data["danso"];
            this.ghichu = _data["ghichu"];
        }
    }

    static fromJS(data: any): TinhDto {
        data = typeof data === 'object' ? data : {};
        let result = new TinhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["wbk_geometry"] = this.wbk_geometry;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        data["ten_dvhc_t"] = this.ten_dvhc_t;
        data["dientich"] = this.dientich;
        data["danso"] = this.danso;
        data["ghichu"] = this.ghichu;
        return data; 
    }

    clone(): TinhDto {
        const json = this.toJSON();
        let result = new TinhDto();
        result.init(json);
        return result;
    }
}

export interface ITinhDto {
    id: number;
    wbk_geometry: string | undefined;
    ma_dvhc_t: string | undefined;
    ten_dvhc_t: string | undefined;
    dientich: number;
    danso: number;
    ghichu: string | undefined;
}

export class UpdateEmailDto implements IUpdateEmailDto {
    id: number;
    emailAddress: string | undefined;

    constructor(data?: IUpdateEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): UpdateEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): UpdateEmailDto {
        const json = this.toJSON();
        let result = new UpdateEmailDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateEmailDto {
    id: number;
    emailAddress: string | undefined;
}

export class UpdateInfoUserDto implements IUpdateInfoUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    toChuc: OrganizationViewDto[] | undefined;
    userOrg: string[] | undefined;
    phoneNumber: string | undefined;
    avatar: string | undefined;
    address: string | undefined;
    chucDanhId: number | undefined;
    tenChucDanh: string | undefined;

    constructor(data?: IUpdateInfoUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            if (Array.isArray(_data["toChuc"])) {
                this.toChuc = [] as any;
                for (let item of _data["toChuc"])
                    this.toChuc.push(OrganizationViewDto.fromJS(item));
            }
            if (Array.isArray(_data["userOrg"])) {
                this.userOrg = [] as any;
                for (let item of _data["userOrg"])
                    this.userOrg.push(item);
            }
            this.phoneNumber = _data["phoneNumber"];
            this.avatar = _data["avatar"];
            this.address = _data["address"];
            this.chucDanhId = _data["chucDanhId"];
            this.tenChucDanh = _data["tenChucDanh"];
        }
    }

    static fromJS(data: any): UpdateInfoUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInfoUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.toChuc)) {
            data["toChuc"] = [];
            for (let item of this.toChuc)
                data["toChuc"].push(item.toJSON());
        }
        if (Array.isArray(this.userOrg)) {
            data["userOrg"] = [];
            for (let item of this.userOrg)
                data["userOrg"].push(item);
        }
        data["phoneNumber"] = this.phoneNumber;
        data["avatar"] = this.avatar;
        data["address"] = this.address;
        data["chucDanhId"] = this.chucDanhId;
        data["tenChucDanh"] = this.tenChucDanh;
        return data; 
    }

    clone(): UpdateInfoUserDto {
        const json = this.toJSON();
        let result = new UpdateInfoUserDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateInfoUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    toChuc: OrganizationViewDto[] | undefined;
    userOrg: string[] | undefined;
    phoneNumber: string | undefined;
    avatar: string | undefined;
    address: string | undefined;
    chucDanhId: number | undefined;
    tenChucDanh: string | undefined;
}

export class User implements IUser {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    readonly fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    address: string | undefined;
    chucVu: string | undefined;
    organizationUnitId: number | undefined;
    avatar: string | undefined;
    chucDanhId: number | undefined;
    ngayCap: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.address = _data["address"];
            this.chucVu = _data["chucVu"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.avatar = _data["avatar"];
            this.chucDanhId = _data["chucDanhId"];
            this.ngayCap = _data["ngayCap"] ? moment(_data["ngayCap"].toString()) : <any>undefined;
            this.ngayHetHan = _data["ngayHetHan"] ? moment(_data["ngayHetHan"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["address"] = this.address;
        data["chucVu"] = this.chucVu;
        data["organizationUnitId"] = this.organizationUnitId;
        data["avatar"] = this.avatar;
        data["chucDanhId"] = this.chucDanhId;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    address: string | undefined;
    chucVu: string | undefined;
    organizationUnitId: number | undefined;
    avatar: string | undefined;
    chucDanhId: number | undefined;
    ngayCap: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;
}

export class UserBCDto implements IUserBCDto {
    id: number;
    userName: string | undefined;

    constructor(data?: IUserBCDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UserBCDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserBCDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): UserBCDto {
        const json = this.toJSON();
        let result = new UserBCDto();
        result.init(json);
        return result;
    }
}

export interface IUserBCDto {
    id: number;
    userName: string | undefined;
}

export class UserClaim implements IUserClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data; 
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
}

export class UserDVHC implements IUserDVHC {
    id: number;
    idUser: number;
    idDVHC: string | undefined;
    dvhC_MaTinh: string | undefined;
    dvhC_MaHuyen: string | undefined;
    dvhC_MaXa: string | undefined;
    ma_dvhc_t: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_x: string | undefined;

    constructor(data?: IUserDVHC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idUser = _data["idUser"];
            this.idDVHC = _data["idDVHC"];
            this.dvhC_MaTinh = _data["dvhC_MaTinh"];
            this.dvhC_MaHuyen = _data["dvhC_MaHuyen"];
            this.dvhC_MaXa = _data["dvhC_MaXa"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
            this.ma_dvhc_h = _data["ma_dvhc_h"];
            this.ma_dvhc_x = _data["ma_dvhc_x"];
        }
    }

    static fromJS(data: any): UserDVHC {
        data = typeof data === 'object' ? data : {};
        let result = new UserDVHC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idUser"] = this.idUser;
        data["idDVHC"] = this.idDVHC;
        data["dvhC_MaTinh"] = this.dvhC_MaTinh;
        data["dvhC_MaHuyen"] = this.dvhC_MaHuyen;
        data["dvhC_MaXa"] = this.dvhC_MaXa;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        data["ma_dvhc_h"] = this.ma_dvhc_h;
        data["ma_dvhc_x"] = this.ma_dvhc_x;
        return data; 
    }

    clone(): UserDVHC {
        const json = this.toJSON();
        let result = new UserDVHC();
        result.init(json);
        return result;
    }
}

export interface IUserDVHC {
    id: number;
    idUser: number;
    idDVHC: string | undefined;
    dvhC_MaTinh: string | undefined;
    dvhC_MaHuyen: string | undefined;
    dvhC_MaXa: string | undefined;
    ma_dvhc_t: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_x: string | undefined;
}

export class UserDVHCViewDto implements IUserDVHCViewDto {
    id: number;
    name: string | undefined;
    userName: string | undefined;
    roleID: number;
    isChecked: boolean;

    constructor(data?: IUserDVHCViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.roleID = _data["roleID"];
            this.isChecked = _data["isChecked"];
        }
    }

    static fromJS(data: any): UserDVHCViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDVHCViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["roleID"] = this.roleID;
        data["isChecked"] = this.isChecked;
        return data; 
    }

    clone(): UserDVHCViewDto {
        const json = this.toJSON();
        let result = new UserDVHCViewDto();
        result.init(json);
        return result;
    }
}

export interface IUserDVHCViewDto {
    id: number;
    name: string | undefined;
    userName: string | undefined;
    roleID: number;
    isChecked: boolean;
}

export class UserDVHCViewDtoPagedResultDto implements IUserDVHCViewDtoPagedResultDto {
    items: UserDVHCViewDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserDVHCViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDVHCViewDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserDVHCViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDVHCViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): UserDVHCViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDVHCViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDVHCViewDtoPagedResultDto {
    items: UserDVHCViewDto[] | undefined;
    totalCount: number;
}

export class UserDoiTuong implements IUserDoiTuong {
    id: number;
    userId: number;
    doiTuongId: number;
    isActive: boolean;
    type: NhacViecType;
    mocDauTien: moment.Moment | undefined;
    nhacTruoc: number;
    noiDung: string | undefined;

    constructor(data?: IUserDoiTuong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.doiTuongId = _data["doiTuongId"];
            this.isActive = _data["isActive"];
            this.type = _data["type"];
            this.mocDauTien = _data["mocDauTien"] ? moment(_data["mocDauTien"].toString()) : <any>undefined;
            this.nhacTruoc = _data["nhacTruoc"];
            this.noiDung = _data["noiDung"];
        }
    }

    static fromJS(data: any): UserDoiTuong {
        data = typeof data === 'object' ? data : {};
        let result = new UserDoiTuong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["doiTuongId"] = this.doiTuongId;
        data["isActive"] = this.isActive;
        data["type"] = this.type;
        data["mocDauTien"] = this.mocDauTien ? this.mocDauTien.toISOString() : <any>undefined;
        data["nhacTruoc"] = this.nhacTruoc;
        data["noiDung"] = this.noiDung;
        return data; 
    }

    clone(): UserDoiTuong {
        const json = this.toJSON();
        let result = new UserDoiTuong();
        result.init(json);
        return result;
    }
}

export interface IUserDoiTuong {
    id: number;
    userId: number;
    doiTuongId: number;
    isActive: boolean;
    type: NhacViecType;
    mocDauTien: moment.Moment | undefined;
    nhacTruoc: number;
    noiDung: string | undefined;
}

export class UserDoiTuongDto implements IUserDoiTuongDto {
    id: number;
    userId: number;
    objDoiTuong: ObjDoiTuong[] | undefined;

    constructor(data?: IUserDoiTuongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["objDoiTuong"])) {
                this.objDoiTuong = [] as any;
                for (let item of _data["objDoiTuong"])
                    this.objDoiTuong.push(ObjDoiTuong.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDoiTuongDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDoiTuongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        if (Array.isArray(this.objDoiTuong)) {
            data["objDoiTuong"] = [];
            for (let item of this.objDoiTuong)
                data["objDoiTuong"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserDoiTuongDto {
        const json = this.toJSON();
        let result = new UserDoiTuongDto();
        result.init(json);
        return result;
    }
}

export interface IUserDoiTuongDto {
    id: number;
    userId: number;
    objDoiTuong: ObjDoiTuong[] | undefined;
}

export class UserDoiTuongViewDto implements IUserDoiTuongViewDto {
    id: number;
    userName: string | undefined;
    fullName: string | undefined;
    phoneNumber: string | undefined;
    tenToChuc: string | undefined;
    organizationUnitId: number | undefined;
    doiTuong: string[] | undefined;

    constructor(data?: IUserDoiTuongViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.phoneNumber = _data["phoneNumber"];
            this.tenToChuc = _data["tenToChuc"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["doiTuong"])) {
                this.doiTuong = [] as any;
                for (let item of _data["doiTuong"])
                    this.doiTuong.push(item);
            }
        }
    }

    static fromJS(data: any): UserDoiTuongViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDoiTuongViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["phoneNumber"] = this.phoneNumber;
        data["tenToChuc"] = this.tenToChuc;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.doiTuong)) {
            data["doiTuong"] = [];
            for (let item of this.doiTuong)
                data["doiTuong"].push(item);
        }
        return data; 
    }

    clone(): UserDoiTuongViewDto {
        const json = this.toJSON();
        let result = new UserDoiTuongViewDto();
        result.init(json);
        return result;
    }
}

export interface IUserDoiTuongViewDto {
    id: number;
    userName: string | undefined;
    fullName: string | undefined;
    phoneNumber: string | undefined;
    tenToChuc: string | undefined;
    organizationUnitId: number | undefined;
    doiTuong: string[] | undefined;
}

export class UserDto implements IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    toChuc: OrganizationViewDto[] | undefined;
    userOrg: string[] | undefined;
    phoneNumber: string | undefined;
    avatar: string | undefined;
    address: string | undefined;
    chucDanhId: number | undefined;
    tenChucDanh: string | undefined;
    ngayCap: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            if (Array.isArray(_data["toChuc"])) {
                this.toChuc = [] as any;
                for (let item of _data["toChuc"])
                    this.toChuc.push(OrganizationViewDto.fromJS(item));
            }
            if (Array.isArray(_data["userOrg"])) {
                this.userOrg = [] as any;
                for (let item of _data["userOrg"])
                    this.userOrg.push(item);
            }
            this.phoneNumber = _data["phoneNumber"];
            this.avatar = _data["avatar"];
            this.address = _data["address"];
            this.chucDanhId = _data["chucDanhId"];
            this.tenChucDanh = _data["tenChucDanh"];
            this.ngayCap = _data["ngayCap"] ? moment(_data["ngayCap"].toString()) : <any>undefined;
            this.ngayHetHan = _data["ngayHetHan"] ? moment(_data["ngayHetHan"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.toChuc)) {
            data["toChuc"] = [];
            for (let item of this.toChuc)
                data["toChuc"].push(item.toJSON());
        }
        if (Array.isArray(this.userOrg)) {
            data["userOrg"] = [];
            for (let item of this.userOrg)
                data["userOrg"].push(item);
        }
        data["phoneNumber"] = this.phoneNumber;
        data["avatar"] = this.avatar;
        data["address"] = this.address;
        data["chucDanhId"] = this.chucDanhId;
        data["tenChucDanh"] = this.tenChucDanh;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    toChuc: OrganizationViewDto[] | undefined;
    userOrg: string[] | undefined;
    phoneNumber: string | undefined;
    avatar: string | undefined;
    address: string | undefined;
    chucDanhId: number | undefined;
    tenChucDanh: string | undefined;
    ngayCap: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class UserLogin implements IUserLogin {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        return data; 
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    avatar: string | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["avatar"] = this.avatar;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    avatar: string | undefined;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    userId: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    userId: number;
}

export class UserRole implements IUserRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    roleId: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    roleId: number;
}

export class UserToken implements IUserToken {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
}

export class UserViewDto implements IUserViewDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    readonly fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    address: string | undefined;
    chucVu: string | undefined;
    organizationUnitId: number | undefined;
    avatar: string | undefined;
    chucDanhId: number | undefined;
    ngayCap: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;
    toChuc: string[] | undefined;
    tenNhom: string[] | undefined;

    constructor(data?: IUserViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.address = _data["address"];
            this.chucVu = _data["chucVu"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.avatar = _data["avatar"];
            this.chucDanhId = _data["chucDanhId"];
            this.ngayCap = _data["ngayCap"] ? moment(_data["ngayCap"].toString()) : <any>undefined;
            this.ngayHetHan = _data["ngayHetHan"] ? moment(_data["ngayHetHan"].toString()) : <any>undefined;
            if (Array.isArray(_data["toChuc"])) {
                this.toChuc = [] as any;
                for (let item of _data["toChuc"])
                    this.toChuc.push(item);
            }
            if (Array.isArray(_data["tenNhom"])) {
                this.tenNhom = [] as any;
                for (let item of _data["tenNhom"])
                    this.tenNhom.push(item);
            }
        }
    }

    static fromJS(data: any): UserViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["address"] = this.address;
        data["chucVu"] = this.chucVu;
        data["organizationUnitId"] = this.organizationUnitId;
        data["avatar"] = this.avatar;
        data["chucDanhId"] = this.chucDanhId;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        if (Array.isArray(this.toChuc)) {
            data["toChuc"] = [];
            for (let item of this.toChuc)
                data["toChuc"].push(item);
        }
        if (Array.isArray(this.tenNhom)) {
            data["tenNhom"] = [];
            for (let item of this.tenNhom)
                data["tenNhom"].push(item);
        }
        return data; 
    }

    clone(): UserViewDto {
        const json = this.toJSON();
        let result = new UserViewDto();
        result.init(json);
        return result;
    }
}

export interface IUserViewDto {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    address: string | undefined;
    chucVu: string | undefined;
    organizationUnitId: number | undefined;
    avatar: string | undefined;
    chucDanhId: number | undefined;
    ngayCap: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;
    toChuc: string[] | undefined;
    tenNhom: string[] | undefined;
}

export class UserViewDtoPagedResultDto implements IUserViewDtoPagedResultDto {
    items: UserViewDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserViewDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserViewDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserViewDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserViewDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): UserViewDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserViewDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserViewDtoPagedResultDto {
    items: UserViewDto[] | undefined;
    totalCount: number;
}

export class ViewHuyenDto implements IViewHuyenDto {
    id: number;
    wkb_geometry: string | undefined;
    ma_dvhc_h: string | undefined;
    ten_dvhc_h: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    ghichu: string | undefined;
    ma_dvhc_t: string | undefined;

    constructor(data?: IViewHuyenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.wkb_geometry = _data["wkb_geometry"];
            this.ma_dvhc_h = _data["ma_dvhc_h"];
            this.ten_dvhc_h = _data["ten_dvhc_h"];
            this.dientich = _data["dientich"];
            this.dan_so = _data["dan_so"];
            this.tentinh = _data["tentinh"];
            this.ghichu = _data["ghichu"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
        }
    }

    static fromJS(data: any): ViewHuyenDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewHuyenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["wkb_geometry"] = this.wkb_geometry;
        data["ma_dvhc_h"] = this.ma_dvhc_h;
        data["ten_dvhc_h"] = this.ten_dvhc_h;
        data["dientich"] = this.dientich;
        data["dan_so"] = this.dan_so;
        data["tentinh"] = this.tentinh;
        data["ghichu"] = this.ghichu;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        return data; 
    }

    clone(): ViewHuyenDto {
        const json = this.toJSON();
        let result = new ViewHuyenDto();
        result.init(json);
        return result;
    }
}

export interface IViewHuyenDto {
    id: number;
    wkb_geometry: string | undefined;
    ma_dvhc_h: string | undefined;
    ten_dvhc_h: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    ghichu: string | undefined;
    ma_dvhc_t: string | undefined;
}

export class ViewTinhDto implements IViewTinhDto {
    id: number;
    wbk_geometry: string | undefined;
    ma_dvhc_t: string | undefined;
    ten_dvhc_t: string | undefined;
    dientich: number;
    danso: number;
    ghichu: string | undefined;

    constructor(data?: IViewTinhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.wbk_geometry = _data["wbk_geometry"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
            this.ten_dvhc_t = _data["ten_dvhc_t"];
            this.dientich = _data["dientich"];
            this.danso = _data["danso"];
            this.ghichu = _data["ghichu"];
        }
    }

    static fromJS(data: any): ViewTinhDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewTinhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["wbk_geometry"] = this.wbk_geometry;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        data["ten_dvhc_t"] = this.ten_dvhc_t;
        data["dientich"] = this.dientich;
        data["danso"] = this.danso;
        data["ghichu"] = this.ghichu;
        return data; 
    }

    clone(): ViewTinhDto {
        const json = this.toJSON();
        let result = new ViewTinhDto();
        result.init(json);
        return result;
    }
}

export interface IViewTinhDto {
    id: number;
    wbk_geometry: string | undefined;
    ma_dvhc_t: string | undefined;
    ten_dvhc_t: string | undefined;
    dientich: number;
    danso: number;
    ghichu: string | undefined;
}

export class ViewXaDto implements IViewXaDto {
    id: number;
    wkb_geometry: string | undefined;
    ma_dvhc_x: string | undefined;
    ten_dvhc_x: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_t: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    tenhuyen: string | undefined;
    ghichu: string | undefined;

    constructor(data?: IViewXaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.wkb_geometry = _data["wkb_geometry"];
            this.ma_dvhc_x = _data["ma_dvhc_x"];
            this.ten_dvhc_x = _data["ten_dvhc_x"];
            this.ma_dvhc_h = _data["ma_dvhc_h"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
            this.dientich = _data["dientich"];
            this.dan_so = _data["dan_so"];
            this.tentinh = _data["tentinh"];
            this.tenhuyen = _data["tenhuyen"];
            this.ghichu = _data["ghichu"];
        }
    }

    static fromJS(data: any): ViewXaDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViewXaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["wkb_geometry"] = this.wkb_geometry;
        data["ma_dvhc_x"] = this.ma_dvhc_x;
        data["ten_dvhc_x"] = this.ten_dvhc_x;
        data["ma_dvhc_h"] = this.ma_dvhc_h;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        data["dientich"] = this.dientich;
        data["dan_so"] = this.dan_so;
        data["tentinh"] = this.tentinh;
        data["tenhuyen"] = this.tenhuyen;
        data["ghichu"] = this.ghichu;
        return data; 
    }

    clone(): ViewXaDto {
        const json = this.toJSON();
        let result = new ViewXaDto();
        result.init(json);
        return result;
    }
}

export interface IViewXaDto {
    id: number;
    wkb_geometry: string | undefined;
    ma_dvhc_x: string | undefined;
    ten_dvhc_x: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_t: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    tenhuyen: string | undefined;
    ghichu: string | undefined;
}

export class Xa implements IXa {
    id: number;
    wkb_geometry: Geometry[] | undefined;
    ma_dvhc_x: string | undefined;
    ten_dvhc_x: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_t: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    tenhuyen: string | undefined;
    ghichu: string | undefined;

    constructor(data?: IXa) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["wkb_geometry"])) {
                this.wkb_geometry = [] as any;
                for (let item of _data["wkb_geometry"])
                    this.wkb_geometry.push(Geometry.fromJS(item));
            }
            this.ma_dvhc_x = _data["ma_dvhc_x"];
            this.ten_dvhc_x = _data["ten_dvhc_x"];
            this.ma_dvhc_h = _data["ma_dvhc_h"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
            this.dientich = _data["dientich"];
            this.dan_so = _data["dan_so"];
            this.tentinh = _data["tentinh"];
            this.tenhuyen = _data["tenhuyen"];
            this.ghichu = _data["ghichu"];
        }
    }

    static fromJS(data: any): Xa {
        data = typeof data === 'object' ? data : {};
        let result = new Xa();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.wkb_geometry)) {
            data["wkb_geometry"] = [];
            for (let item of this.wkb_geometry)
                data["wkb_geometry"].push(item.toJSON());
        }
        data["ma_dvhc_x"] = this.ma_dvhc_x;
        data["ten_dvhc_x"] = this.ten_dvhc_x;
        data["ma_dvhc_h"] = this.ma_dvhc_h;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        data["dientich"] = this.dientich;
        data["dan_so"] = this.dan_so;
        data["tentinh"] = this.tentinh;
        data["tenhuyen"] = this.tenhuyen;
        data["ghichu"] = this.ghichu;
        return data; 
    }

    clone(): Xa {
        const json = this.toJSON();
        let result = new Xa();
        result.init(json);
        return result;
    }
}

export interface IXa {
    id: number;
    wkb_geometry: Geometry[] | undefined;
    ma_dvhc_x: string | undefined;
    ten_dvhc_x: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_t: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    tenhuyen: string | undefined;
    ghichu: string | undefined;
}

export class XaDto implements IXaDto {
    id: number;
    wkb_geometry: string | undefined;
    ma_dvhc_x: string | undefined;
    ten_dvhc_x: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_t: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    tenhuyen: string | undefined;
    ghichu: string | undefined;

    constructor(data?: IXaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.wkb_geometry = _data["wkb_geometry"];
            this.ma_dvhc_x = _data["ma_dvhc_x"];
            this.ten_dvhc_x = _data["ten_dvhc_x"];
            this.ma_dvhc_h = _data["ma_dvhc_h"];
            this.ma_dvhc_t = _data["ma_dvhc_t"];
            this.dientich = _data["dientich"];
            this.dan_so = _data["dan_so"];
            this.tentinh = _data["tentinh"];
            this.tenhuyen = _data["tenhuyen"];
            this.ghichu = _data["ghichu"];
        }
    }

    static fromJS(data: any): XaDto {
        data = typeof data === 'object' ? data : {};
        let result = new XaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["wkb_geometry"] = this.wkb_geometry;
        data["ma_dvhc_x"] = this.ma_dvhc_x;
        data["ten_dvhc_x"] = this.ten_dvhc_x;
        data["ma_dvhc_h"] = this.ma_dvhc_h;
        data["ma_dvhc_t"] = this.ma_dvhc_t;
        data["dientich"] = this.dientich;
        data["dan_so"] = this.dan_so;
        data["tentinh"] = this.tentinh;
        data["tenhuyen"] = this.tenhuyen;
        data["ghichu"] = this.ghichu;
        return data; 
    }

    clone(): XaDto {
        const json = this.toJSON();
        let result = new XaDto();
        result.init(json);
        return result;
    }
}

export interface IXaDto {
    id: number;
    wkb_geometry: string | undefined;
    ma_dvhc_x: string | undefined;
    ten_dvhc_x: string | undefined;
    ma_dvhc_h: string | undefined;
    ma_dvhc_t: string | undefined;
    dientich: number;
    dan_so: number;
    tentinh: string | undefined;
    tenhuyen: string | undefined;
    ghichu: string | undefined;
}

export class XemDoiTuongUserEmpty implements IXemDoiTuongUserEmpty {
    id: number;
    name: string | undefined;
    ngayNhacViec: moment.Moment | undefined;
    isActive: boolean;
    nhacTruoc: number;
    noiDung: string | undefined;
    isChecked: boolean;
    type: number;

    constructor(data?: IXemDoiTuongUserEmpty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.ngayNhacViec = _data["ngayNhacViec"] ? moment(_data["ngayNhacViec"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.nhacTruoc = _data["nhacTruoc"];
            this.noiDung = _data["noiDung"];
            this.isChecked = _data["isChecked"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): XemDoiTuongUserEmpty {
        data = typeof data === 'object' ? data : {};
        let result = new XemDoiTuongUserEmpty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["ngayNhacViec"] = this.ngayNhacViec ? this.ngayNhacViec.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["nhacTruoc"] = this.nhacTruoc;
        data["noiDung"] = this.noiDung;
        data["isChecked"] = this.isChecked;
        data["type"] = this.type;
        return data; 
    }

    clone(): XemDoiTuongUserEmpty {
        const json = this.toJSON();
        let result = new XemDoiTuongUserEmpty();
        result.init(json);
        return result;
    }
}

export interface IXemDoiTuongUserEmpty {
    id: number;
    name: string | undefined;
    ngayNhacViec: moment.Moment | undefined;
    isActive: boolean;
    nhacTruoc: number;
    noiDung: string | undefined;
    isChecked: boolean;
    type: number;
}

export class XemUserDoiTuong implements IXemUserDoiTuong {
    id: number;
    doiTuongId: number;
    userId: number;
    isActive: boolean;

    constructor(data?: IXemUserDoiTuong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.doiTuongId = _data["doiTuongId"];
            this.userId = _data["userId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): XemUserDoiTuong {
        data = typeof data === 'object' ? data : {};
        let result = new XemUserDoiTuong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["doiTuongId"] = this.doiTuongId;
        data["userId"] = this.userId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): XemUserDoiTuong {
        const json = this.toJSON();
        let result = new XemUserDoiTuong();
        result.init(json);
        return result;
    }
}

export interface IXemUserDoiTuong {
    id: number;
    doiTuongId: number;
    userId: number;
    isActive: boolean;
}

export class XemUserDoiTuongDto implements IXemUserDoiTuongDto {
    id: number;
    userId: number;
    objDoiTuong: ObjDoiTuongXem[] | undefined;

    constructor(data?: IXemUserDoiTuongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["objDoiTuong"])) {
                this.objDoiTuong = [] as any;
                for (let item of _data["objDoiTuong"])
                    this.objDoiTuong.push(ObjDoiTuongXem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XemUserDoiTuongDto {
        data = typeof data === 'object' ? data : {};
        let result = new XemUserDoiTuongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        if (Array.isArray(this.objDoiTuong)) {
            data["objDoiTuong"] = [];
            for (let item of this.objDoiTuong)
                data["objDoiTuong"].push(item.toJSON());
        }
        return data; 
    }

    clone(): XemUserDoiTuongDto {
        const json = this.toJSON();
        let result = new XemUserDoiTuongDto();
        result.init(json);
        return result;
    }
}

export interface IXemUserDoiTuongDto {
    id: number;
    userId: number;
    objDoiTuong: ObjDoiTuongXem[] | undefined;
}

export class XemUserDoiTuongViewDto implements IXemUserDoiTuongViewDto {
    id: number;
    userName: string | undefined;
    fullName: string | undefined;
    phoneNumber: string | undefined;
    tenToChuc: string | undefined;
    organizationUnitId: number | undefined;
    doiTuong: string[] | undefined;

    constructor(data?: IXemUserDoiTuongViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.phoneNumber = _data["phoneNumber"];
            this.tenToChuc = _data["tenToChuc"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["doiTuong"])) {
                this.doiTuong = [] as any;
                for (let item of _data["doiTuong"])
                    this.doiTuong.push(item);
            }
        }
    }

    static fromJS(data: any): XemUserDoiTuongViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new XemUserDoiTuongViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["phoneNumber"] = this.phoneNumber;
        data["tenToChuc"] = this.tenToChuc;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.doiTuong)) {
            data["doiTuong"] = [];
            for (let item of this.doiTuong)
                data["doiTuong"].push(item);
        }
        return data; 
    }

    clone(): XemUserDoiTuongViewDto {
        const json = this.toJSON();
        let result = new XemUserDoiTuongViewDto();
        result.init(json);
        return result;
    }
}

export interface IXemUserDoiTuongViewDto {
    id: number;
    userName: string | undefined;
    fullName: string | undefined;
    phoneNumber: string | undefined;
    tenToChuc: string | undefined;
    organizationUnitId: number | undefined;
    doiTuong: string[] | undefined;
}

export class ObjDoiTuong implements IObjDoiTuong {
    doiTuongId: number;
    isActive: boolean;
    type: NhacViecType;
    mocDauTien: moment.Moment | undefined;
    nhacTruoc: number;
    noiDung: string | undefined;

    constructor(data?: IObjDoiTuong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.doiTuongId = _data["doiTuongId"];
            this.isActive = _data["isActive"];
            this.type = _data["type"];
            this.mocDauTien = _data["mocDauTien"] ? moment(_data["mocDauTien"].toString()) : <any>undefined;
            this.nhacTruoc = _data["nhacTruoc"];
            this.noiDung = _data["noiDung"];
        }
    }

    static fromJS(data: any): ObjDoiTuong {
        data = typeof data === 'object' ? data : {};
        let result = new ObjDoiTuong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["doiTuongId"] = this.doiTuongId;
        data["isActive"] = this.isActive;
        data["type"] = this.type;
        data["mocDauTien"] = this.mocDauTien ? this.mocDauTien.toISOString() : <any>undefined;
        data["nhacTruoc"] = this.nhacTruoc;
        data["noiDung"] = this.noiDung;
        return data; 
    }

    clone(): ObjDoiTuong {
        const json = this.toJSON();
        let result = new ObjDoiTuong();
        result.init(json);
        return result;
    }
}

export interface IObjDoiTuong {
    doiTuongId: number;
    isActive: boolean;
    type: NhacViecType;
    mocDauTien: moment.Moment | undefined;
    nhacTruoc: number;
    noiDung: string | undefined;
}

export class ObjDoiTuongDuyet implements IObjDoiTuongDuyet {
    doiTuongId: number;
    isActive: boolean;

    constructor(data?: IObjDoiTuongDuyet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.doiTuongId = _data["doiTuongId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ObjDoiTuongDuyet {
        data = typeof data === 'object' ? data : {};
        let result = new ObjDoiTuongDuyet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["doiTuongId"] = this.doiTuongId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ObjDoiTuongDuyet {
        const json = this.toJSON();
        let result = new ObjDoiTuongDuyet();
        result.init(json);
        return result;
    }
}

export interface IObjDoiTuongDuyet {
    doiTuongId: number;
    isActive: boolean;
}

export class ObjDoiTuongXem implements IObjDoiTuongXem {
    doiTuongId: number;
    isActive: boolean;

    constructor(data?: IObjDoiTuongXem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.doiTuongId = _data["doiTuongId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ObjDoiTuongXem {
        data = typeof data === 'object' ? data : {};
        let result = new ObjDoiTuongXem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["doiTuongId"] = this.doiTuongId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ObjDoiTuongXem {
        const json = this.toJSON();
        let result = new ObjDoiTuongXem();
        result.init(json);
        return result;
    }
}

export interface IObjDoiTuongXem {
    doiTuongId: number;
    isActive: boolean;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}